#nullable enable
namespace NucliaDB.Generated;

/// <summary>HTTPValidationError</summary>
/// <param name="Detail">Detail</param>
public record HTTPValidationError(List<ValidationError> Detail);

/// <summary>LearningConfigurationUpdate</summary>
/// <param name="AnonymizationModel">AnonymizationModel</param>
/// <param name="GenerativeModel">GenerativeModel</param>
/// <param name="NerModel">NerModel</param>
public record LearningConfigurationUpdate(object AnonymizationModel, object GenerativeModel, object NerModel);

/// <summary>Model to map in a generic way what we really store on the db, without valdations. As enum values containing the versions change from time to time, and we don't keep historics, we cannot use the model enums here, as it will fail with older values</summary>
/// <param name="SemanticModel">SemanticModel</param>
/// <param name="AnonymizationModel">AnonymizationModel</param>
/// <param name="GenerativeModel">GenerativeModel</param>
/// <param name="NerModel">NerModel</param>
/// <param name="SemanticVectorSimilarity">SemanticVectorSimilarity</param>
/// <param name="SemanticVectorSize">SemanticVectorSize</param>
public record StoredLearningConfiguration(string SemanticModel, string AnonymizationModel, string GenerativeModel, string NerModel, string SemanticVectorSimilarity, int SemanticVectorSize);

/// <summary>ValidationError</summary>
/// <param name="Loc">Loc</param>
/// <param name="Msg">Msg</param>
/// <param name="Type">Type</param>
public record ValidationError(List<object> Loc, string Msg, string Type);

/// <summary>AgentsFilter</summary>
/// <param name="Type">Type</param>
/// <param name="TaskNames">list of task names. If None or empty, all tasks for that operation are applied.</param>
public record AgentsFilter(string Type, List<string> TaskNames);

/// <summary>AndFieldFilterExpression</summary>

public record AndFieldFilterExpression();

/// <summary>AndGraphNodesQuery</summary>
/// <param name="Operands">Operands</param>
public record AndGraphNodesQuery(List<object> Operands);

/// <summary>AndGraphPathQuery</summary>

public record AndGraphPathQuery();

/// <summary>AndGraphRelationsQuery</summary>
/// <param name="Operands">Operands</param>
public record AndGraphRelationsQuery(List<object> Operands);

/// <summary>AndParagraphFilterExpression</summary>

public record AndParagraphFilterExpression();

/// <summary>AndResourceFilterExpression</summary>
/// <param name="Operands">Operands</param>
public record AndResourceFilterExpression(List<object> Operands);

/// <summary>Answer</summary>
/// <param name="Text">Text</param>
/// <param name="Language">Language</param>
/// <param name="IdsParagraphs">IdsParagraphs</param>
public record Answer(string Text, string? Language, List<string> IdsParagraphs);

/// <summary>AnyNode</summary>
/// <param name="Prop">Prop</param>
/// <param name="Value">Value</param>
/// <param name="Match">Match</param>
/// <param name="Type">Type</param>
/// <param name="Group">Group</param>
public record AnyNode(string Prop, string? Value, string Match, string? Type, string? Group);

/// <summary>AppliedDataAugmentation</summary>
/// <param name="Qas">Question and answers generated by the Question Answers agent</param>
/// <param name="NewTextFields">New text fields. Only generated by the Generator agent as of now.</param>
/// <param name="Changed">Indicates if the FieldMetadata was changed by the agents</param>
public record AppliedDataAugmentation(QuestionAnswers? Qas, List<NewTextField> NewTextFields, bool Changed);

/// <summary>AskRequest</summary>
/// <param name="AuditMetadata">A dictionary containing optional audit-specific metadata, such as user_id, environment, or other contextual information. This metadata can be leveraged for filtering and analyzing activity logs in future operations. Each key-value pair represents a piece of metadata relevant to the user's request.</param>
/// <param name="Query">The query to get a generative answer for</param>
/// <param name="TopK">The top most relevant results to fetch at the retrieval step. The maximum number of results allowed is 200.</param>
/// <param name="FilterExpression">Returns only documents that match this filter expression.Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters This allows building complex filtering expressions and replaces the following parameters:`fields`, `filters`, `range_*`, `resource_filters`, `keyword_filters`.</param>
/// <param name="Fields">The list of fields to search in. For instance: `a/title` to search only on title field. For more details on filtering by field, see: https://docs.nuclia.dev/docs/rag/advanced/search/#search-in-a-specific-field.</param>
/// <param name="Filters">The list of filters to apply. Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters</param>
/// <param name="KeywordFilters">List of keyword filter expressions to apply to the retrieval step. The text block search will only be performed on the documents that contain the specified keywords. The filters are case-insensitive, and only alphanumeric characters and spaces are allowed. Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters</param>
/// <param name="Vectorset">Vectors index to perform the search in. If not provided, NucliaDB will use the default one</param>
/// <param name="MinScore">Minimum score to filter search results. Results with a lower score will be ignored. Accepts either a float or a dictionary with the minimum scores for the bm25 and vector indexes. If a float is provided, it is interpreted as the minimum score for vector index search.</param>
/// <param name="Features">Features enabled for the chat endpoint. Semantic search is done if `semantic` is included. If `keyword` is included, the results will include matching paragraphs from the bm25 index. If `relations` is included, a graph of entities related to the answer is returned. `paragraphs` and `vectors` are deprecated, please use `keyword` and `semantic` instead</param>
/// <param name="RangeCreationStart">Resources created before this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</param>
/// <param name="RangeCreationEnd">Resources created after this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</param>
/// <param name="RangeModificationStart">Resources modified before this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</param>
/// <param name="RangeModificationEnd">Resources modified after this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</param>
/// <param name="Show">Controls which types of metadata are serialized on resources of search results</param>
/// <param name="FieldTypeFilter">Define which field types are serialized on resources of search results</param>
/// <param name="Extracted">[Deprecated] Please use GET resource endpoint instead to get extracted metadata</param>
/// <param name="Context">DEPRECATED! Please, use `chat_history` instead.</param>
/// <param name="ChatHistory">Use to rephrase the new LLM query by taking into account the chat conversation history. This will be passed to the LLM so that it is aware of the previous conversation.</param>
/// <param name="ExtraContext">Additional context that is added to the retrieval context sent to the LLM.         It allows extending the chat feature with content that may not be in the Knowledge Box.</param>
/// <param name="ExtraContextImages">Additional images added to the retrieval context sent to the LLM."         It allows extending the chat feature with content that may not be in the Knowledge Box.</param>
/// <param name="QueryImage">Image that will be used together with the query text for retrieval and then sent to the LLM as part of the context. If a query image is provided, the `extra_context_images` and `rag_images_strategies` will be disabled.</param>
/// <param name="Autofilter">If set to true, the search will automatically add filters to the query. For example, it will filter results containing the entities detected in the query</param>
/// <param name="Highlight">If set to true, the query terms will be highlighted in the results between <mark>...</mark> tags</param>
/// <param name="ResourceFilters">List of resource ids to filter search results for. Only paragraphs from the specified resources will be returned.</param>
/// <param name="Prompt">Use to customize the prompts given to the generative model. Both system and user prompts can be customized. If a string is provided, it is interpreted as the user prompt.</param>
/// <param name="RankFusion">Rank fusion algorithm to use to merge results from multiple retrievers (keyword, semantic)</param>
/// <param name="Reranker">Reranker let you specify which method you want to use to rerank your results at the end of retrieval</param>
/// <param name="Citations">Whether to include the citations for the answer in the response</param>
/// <param name="CitationThreshold">If citations is True, this sets the similarity threshold (0 to 1) for paragraphs to be included as citations. Lower values result in more citations. If not provided, Nuclia's default threshold is used.</param>
/// <param name="Security">Security metadata for the request. If not provided, the search request is done without the security lookup phase.</param>
/// <param name="ShowHidden">If set to false (default), excludes hidden resources from search</param>
/// <param name="RagStrategies">Options for tweaking how the context for the LLM model is crafted: - `full_resource` will add the full text of the matching resources to the context. This strategy cannot be combined with `hierarchy`, `neighbouring_paragraphs`, or `field_extension`. - `field_extension` will add the text of the matching resource's specified fields to the context. - `hierarchy` will add the title and summary text of the parent resource to the context for each matching paragraph. - `neighbouring_paragraphs` will add the sorrounding paragraphs to the context for each matching paragraph. - `metadata_extension` will add the metadata of the matching paragraphs or its resources to the context. - `prequeries` allows to run multiple retrieval queries before the main query and add the results to the context. The results of specific queries can be boosted by the specifying weights.  If empty, the default strategy is used, which simply adds the text of the matching paragraphs to the context.</param>
/// <param name="RagImagesStrategies">Options for tweaking how the image based context for the LLM model is crafted: - `page_image` will add the full page image of the matching resources to the context. - `tables` will send the table images for the paragraphs that contain tables and matched the retrieval query. - `paragraph_image` will add the images of the paragraphs that contain images (images for tables are not included). No image strategy is used by default. Note that this is only available for LLM models that support visual inputs. If the model does not support visual inputs, the image strategies will be ignored.</param>
/// <param name="Debug">If set, the response will include some extra metadata for debugging purposes, like the list of queried nodes.</param>
/// <param name="GenerativeModel">The generative model to use for the chat endpoint. If not provided, the model configured for the Knowledge Box is used.</param>
/// <param name="GenerativeModelSeed">The seed to use for the generative model for deterministic generation. Only supported by some models.</param>
/// <param name="MaxTokens">Use to limit the amount of tokens used in the LLM context and/or for generating the answer. If not provided, the default maximum tokens of the generative model will be used. If an integer is provided, it is interpreted as the maximum tokens for the answer.</param>
/// <param name="Rephrase">Rephrase the query for a more efficient retrieval. This will consume LLM tokens and make the request slower.</param>
/// <param name="ChatHistoryRelevanceThreshold">Threshold to determine if the past chat history is relevant to rephrase the user's question. 0 - Always treat previous messages as relevant (always rephrase).1 - Always treat previous messages as irrelevant (never rephrase).Values in between adjust the sensitivity.</param>
/// <param name="PreferMarkdown">If set to true, the response will be in markdown format</param>
/// <param name="AnswerJsonSchema">Desired JSON schema for the LLM answer. This schema is passed to the LLM so that it answers in a scructured format following the schema. If not provided, textual response is returned. Note that when using this parameter, the answer in the generative response will not be returned in chunks, the whole response text will be returned instead. Using this feature also disables the `citations` parameter. For maximal accuracy, please include a `description` for each field of the schema.</param>
/// <param name="GenerateAnswer">Whether to generate an answer using the generative model. If set to false, the response will only contain the retrieval results.</param>
/// <param name="SearchConfiguration">Load ask parameters from this configuration. Parameters in the request override parameters from the configuration.</param>
/// <param name="Reasoning">Reasoning options for the generative model. Set to True to enable default reasoning, False to disable, or provide a Reasoning object for custom options.</param>
public record AskRequest(object? AuditMetadata, string Query, int TopK, FilterExpression? FilterExpression, List<string> Fields, List<string>? Filters, List<string>? KeywordFilters, string? Vectorset, float? MinScore, List<string> Features, string? RangeCreationStart, string? RangeCreationEnd, string? RangeModificationStart, string? RangeModificationEnd, List<string> Show, List<string> FieldTypeFilter, List<string> Extracted, List<ChatContextMessage>? Context, List<ChatContextMessage>? ChatHistory, List<string>? ExtraContext, List<Image>? ExtraContextImages, Image? QueryImage, bool Autofilter, bool Highlight, List<string> ResourceFilters, string? Prompt, string? RankFusion, string? Reranker, bool Citations, float? CitationThreshold, RequestSecurity? Security, bool ShowHidden, List<object> RagStrategies, List<object> RagImagesStrategies, bool Debug, string? GenerativeModel, int? GenerativeModelSeed, int? MaxTokens, bool Rephrase, float? ChatHistoryRelevanceThreshold, bool PreferMarkdown, object? AnswerJsonSchema, bool GenerateAnswer, string? SearchConfiguration, Reasoning? Reasoning);

/// <summary>AskRetrievalMatch</summary>
/// <param name="Id">Id of the matching text block</param>
public record AskRetrievalMatch(string Id);

/// <summary>AskTimings</summary>
/// <param name="GenerativeFirstChunk">Time the LLM took to generate the first chunk of the answer</param>
/// <param name="GenerativeTotal">Total time the LLM took to generate the answer</param>
public record AskTimings(float? GenerativeFirstChunk, float? GenerativeTotal);

/// <summary>AskTokens</summary>
/// <param name="Input">Number of LLM tokens used for the context in the query</param>
/// <param name="Output">Number of LLM tokens used for the answer</param>
/// <param name="InputNuclia">Number of Nuclia LLM tokens used for the context in the query</param>
/// <param name="OutputNuclia">Number of Nuclia LLM tokens used for the answer</param>
public record AskTokens(int Input, int Output, float? InputNuclia, float? OutputNuclia);

/// <summary>AugmentedContext</summary>
/// <param name="Paragraphs">Paragraphs added to the context as a result of using the `rag_strategies` parameter, typically the neighbouring_paragraphs or the conversation strategies</param>
/// <param name="Fields">Field extracted texts added to the context as a result of using the `rag_strategies` parameter, typically the hierarcy or full_resource strategies.</param>
public record AugmentedContext(object Paragraphs, object Fields);

/// <summary>AugmentedField</summary>
/// <param name="Metadata">Metadata</param>
/// <param name="AppliedDataAugmentation">AppliedDataAugmentation</param>
/// <param name="InputNucliaTokens">InputNucliaTokens</param>
/// <param name="OutputNucliaTokens">OutputNucliaTokens</param>
/// <param name="Time">Time</param>
public record AugmentedField(FieldMetadata Metadata, AppliedDataAugmentation AppliedDataAugmentation, float InputNucliaTokens, float OutputNucliaTokens, float Time);

/// <summary>AugmentedTextBlock</summary>
/// <param name="Id">The id of the augmented text bloc. It can be a paragraph id or a field id.</param>
/// <param name="Text">The text of the augmented text block. It may include additional metadata to enrich the context</param>
/// <param name="Position">Metadata about the position of the text block in the original document.</param>
/// <param name="Parent">The parent text block that was augmented for.</param>
/// <param name="AugmentationType">AugmentationType</param>
public record AugmentedTextBlock(string Id, string Text, TextPosition? Position, string? Parent, string AugmentationType);

/// <summary>Returns only documents that match this filter expression. Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters  This allows building complex filtering expressions and replaces the following parameters: `filters`, `range_*`, `with_status`.</summary>
/// <param name="Resource">Filter to apply to resources</param>
public record CatalogFilterExpression(object Resource);

/// <summary>CatalogQuery</summary>
/// <param name="Field">Field</param>
/// <param name="Match">Match</param>
/// <param name="Query">Text to search for</param>
public record CatalogQuery(string Field, string Match, string Query);

/// <summary>CatalogRequest</summary>
/// <param name="Query">The query to search for</param>
/// <param name="FilterExpression">Returns only documents that match this filter expression.Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters This allows building complex filtering expressions and replaces the following parameters:`filters`, `range_*`, `with_status`.</param>
/// <param name="Faceted">The list of facets to calculate. The facets follow the same syntax as filters: https://docs.nuclia.dev/docs/rag/advanced/search-filters</param>
/// <param name="Sort">Options for results sorting</param>
/// <param name="PageNumber">The page number of the results to return</param>
/// <param name="PageSize">The number of results to return per page. The maximum number of results per page allowed is 200.</param>
/// <param name="Hidden">Set to filter only hidden or only non-hidden resources. Default is to return everything</param>
/// <param name="Show">Controls which types of metadata are serialized on resources of search results</param>
/// <param name="Filters">The list of filters to apply. Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters</param>
/// <param name="WithStatus">Filter results by resource processing status</param>
/// <param name="RangeCreationStart">Resources created before this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</param>
/// <param name="RangeCreationEnd">Resources created after this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</param>
/// <param name="RangeModificationStart">Resources modified before this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</param>
/// <param name="RangeModificationEnd">Resources modified after this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</param>
public record CatalogRequest(string? Query, CatalogFilterExpression? FilterExpression, List<string> Faceted, SortOptions? Sort, int PageNumber, int PageSize, bool? Hidden, List<string> Show, List<string>? Filters, string? WithStatus, string? RangeCreationStart, string? RangeCreationEnd, string? RangeModificationStart, string? RangeModificationEnd);

/// <summary>ChatContextMessage</summary>
/// <param name="Author">Author</param>
/// <param name="Text">Text</param>
public record ChatContextMessage(string Author, string Text);

/// <summary>Classification</summary>
/// <param name="Labelset">Labelset</param>
/// <param name="Label">Label</param>
public record Classification(string Labelset, string Label);

/// <summary>CloudLink</summary>
/// <param name="Uri">Uri</param>
/// <param name="Size">Size</param>
/// <param name="ContentType">ContentType</param>
/// <param name="Filename">Filename</param>
/// <param name="Md5">Md5</param>
public record CloudLink(string? Uri, int? Size, string? ContentType, string? Filename, string? Md5);

/// <summary>The purpose of this field is to show a cherry-picked set of fields from computed metadata without having to load the whole computed metadata field.</summary>
/// <param name="FieldClassifications">FieldClassifications</param>
public record ComputedMetadata(List<FieldClassification> FieldClassifications);

/// <summary>Consumption</summary>
/// <param name="NormalizedTokens">NormalizedTokens</param>
/// <param name="CustomerKeyTokens">CustomerKeyTokens</param>
public record Consumption(TokensDetail NormalizedTokens, TokensDetail CustomerKeyTokens);

/// <summary>ConversationFieldData</summary>
/// <param name="Value">Value</param>
/// <param name="Extracted">Extracted</param>
/// <param name="Error">Error</param>
/// <param name="Status">Status</param>
/// <param name="Errors">Errors</param>
public record ConversationFieldData(FieldConversation? Value, ConversationFieldExtractedData? Extracted, Error? Error, string? Status, List<Error>? Errors);

/// <summary>ConversationFieldExtractedData</summary>
/// <param name="Text">Text</param>
/// <param name="Metadata">Metadata</param>
/// <param name="LargeMetadata">LargeMetadata</param>
/// <param name="Vectors">Vectors</param>
/// <param name="QuestionAnswers">QuestionAnswers</param>
public record ConversationFieldExtractedData(ExtractedText? Text, FieldComputedMetadata? Metadata, LargeComputedMetadata? LargeMetadata, VectorObject? Vectors, FieldQuestionAnswers? QuestionAnswers);

/// <summary>ConversationalStrategy</summary>
/// <param name="Name">Name</param>
/// <param name="AttachmentsText">Add attachments on context retrieved on conversation</param>
/// <param name="AttachmentsImages">Add attachments images on context retrieved on conversation if they are mime type image and using a visual LLM</param>
/// <param name="Full">Add all conversation fields on matched blocks</param>
/// <param name="MaxMessages">Max messages to append in case its not full field</param>
public record ConversationalStrategy(string Name, bool AttachmentsText, bool AttachmentsImages, bool Full, int MaxMessages);

/// <summary>CustomPrompt</summary>
/// <param name="System">System prompt given to the generative model responsible of generating the answer. This can help customize the behavior of the model when generating the answer. If not specified, the default model provider's prompt is used.</param>
/// <param name="User">User prompt given to the generative model responsible of generating the answer. Use the words {context} and {question} in brackets where you want those fields to be placed, in case you want them in your prompt. Context will be the data returned by the retrieval step and question will be the user's query.</param>
/// <param name="Rephrase">Rephrase prompt given to the generative model responsible for rephrasing the query for a more effective retrieval step. This is only used if the `rephrase` flag is set to true in the request. If not specified, Nuclia's default prompt is used. It must include the {question} placeholder. The placeholder will be replaced with the original question</param>
public record CustomPrompt(string? System, string? User, string? Rephrase);

/// <summary>Matches all fields created in a date range</summary>
/// <param name="Prop">Prop</param>
/// <param name="Since">Start of the date range. Leave blank for unbounded</param>
/// <param name="Until">End of the date range. Leave blank for unbounded</param>
public record DateCreated(string Prop, string? Since, string? Until);

/// <summary>Matches all fields modified in a date range</summary>
/// <param name="Prop">Prop</param>
/// <param name="Since">Start of the date range. Leave blank for unbounded</param>
/// <param name="Until">End of the date range. Leave blank for unbounded</param>
public record DateModified(string Prop, string? Since, string? Until);

/// <summary>DestinationNode</summary>
/// <param name="Prop">Prop</param>
/// <param name="Value">Value</param>
/// <param name="Match">Match</param>
/// <param name="Type">Type</param>
/// <param name="Group">Group</param>
public record DestinationNode(string Prop, string? Value, string Match, string? Type, string? Group);

/// <summary>DirectionalRelation</summary>
/// <param name="Entity">Entity</param>
/// <param name="EntityType">EntityType</param>
/// <param name="EntitySubtype">EntitySubtype</param>
/// <param name="Relation">Relation</param>
/// <param name="RelationLabel">RelationLabel</param>
/// <param name="Direction">Direction</param>
/// <param name="Metadata">Metadata</param>
/// <param name="ResourceId">ResourceId</param>
public record DirectionalRelation(string Entity, string EntityType, string EntitySubtype, string Relation, string RelationLabel, string Direction, RelationMetadata? Metadata, string ResourceId);

/// <summary>Matches fields that contains a detected entity</summary>
/// <param name="Prop">Prop</param>
/// <param name="Subtype">Type of the entity. e.g: PERSON</param>
/// <param name="Value">Value of the entity. e.g: Anna. If blank, matches any entity of the given type</param>
public record EntityInput(string Prop, string Subtype, string? Value);

/// <summary>EntityOutput</summary>
/// <param name="Token">Token</param>
/// <param name="Root">Root</param>
/// <param name="Type">Type</param>
public record EntityOutput(string? Token, string? Root, string? Type);

/// <summary>EntitySubgraph</summary>
/// <param name="RelatedTo">RelatedTo</param>
public record EntitySubgraph(List<DirectionalRelation> RelatedTo);

/// <summary>Error</summary>
/// <param name="Body">Body</param>
/// <param name="Code">Code</param>
/// <param name="CodeStr">CodeStr</param>
/// <param name="Created">Created</param>
/// <param name="Severity">Severity</param>
public record Error(string Body, int Code, string CodeStr, string? Created, string Severity);

/// <summary>Extra</summary>
/// <param name="Metadata">Arbitrary JSON metadata provided by the user that is not meant to be searchable, but can be serialized on results.</param>
public record Extra(object Metadata);

/// <summary>ExtractedText</summary>
/// <param name="Text">Text</param>
/// <param name="SplitText">SplitText</param>
/// <param name="DeletedSplits">DeletedSplits</param>
public record ExtractedText(string? Text, object? SplitText, List<string>? DeletedSplits);

/// <summary>FeedbackRequest</summary>
/// <param name="Ident">Id of the request to provide feedback for. This id is returned in the response header `Nuclia-Learning-Id` of the chat endpoint.</param>
/// <param name="Good">Whether the result was good or not</param>
/// <param name="Task">Task</param>
/// <param name="Feedback">Feedback text</param>
/// <param name="TextBlockId">Text block id</param>
public record FeedbackRequest(string Ident, bool Good, string Task, string? Feedback, string? TextBlockId);

/// <summary>Matches a field or set of fields</summary>
/// <param name="Prop">Prop</param>
/// <param name="Type">Type</param>
/// <param name="Name">Name of the field to match. If blank, matches all fields of the given type</param>
public record Field(string Prop, string Type, string? Name);

/// <summary>FieldClassification</summary>
/// <param name="Field">Field</param>
/// <param name="Classifications">Classifications</param>
public record FieldClassification(FieldID Field, List<Classification> Classifications);

/// <summary>FieldComputedMetadata</summary>
/// <param name="Metadata">Metadata</param>
/// <param name="SplitMetadata">SplitMetadata</param>
/// <param name="DeletedSplits">DeletedSplits</param>
public record FieldComputedMetadata(FieldMetadata Metadata, object? SplitMetadata, List<string>? DeletedSplits);

/// <summary>This is a metadata representation of a conversation about how many pages of messages and total of messages we have.  This class is used mainly when exposing a conversation in the resource level</summary>
/// <param name="Pages">Pages</param>
/// <param name="Size">Size</param>
/// <param name="Total">Total</param>
/// <param name="ExtractStrategy">ExtractStrategy</param>
/// <param name="SplitStrategy">SplitStrategy</param>
public record FieldConversation(int? Pages, int? Size, int? Total, string? ExtractStrategy, string? SplitStrategy);

/// <summary>Wrapper for the entities extracted from a field (required because protobuf doesn't support lists of lists)</summary>
/// <param name="Entities">Entities</param>
public record FieldEntities(List<FieldEntity> Entities);

/// <summary>FieldEntity</summary>
/// <param name="Text">Text</param>
/// <param name="Label">Label</param>
/// <param name="Positions">Positions</param>
public record FieldEntity(string Text, string Label, List<Position> Positions);

/// <summary>FieldExtensionStrategy</summary>
/// <param name="Name">Name</param>
/// <param name="Fields">List of field ids to extend the context with. It will try to extend the retrieval context with the specified fields in the matching resources. The field ids have to be in the format `{field_type}/{field_name}`, like 'a/title', 'a/summary' for title and summary fields or 't/amend' for a text field named 'amend'.</param>
public record FieldExtensionStrategy(string Name, List<string> Fields);

/// <summary>FieldFile</summary>
/// <param name="Added">Added</param>
/// <param name="File">File</param>
/// <param name="Language">Language</param>
/// <param name="Password">Password</param>
/// <param name="External">External</param>
/// <param name="ExtractStrategy">Id of the Nuclia extract strategy used at processing time. If not set, the default strategy was used. Extract strategies are defined at the learning configuration api.</param>
/// <param name="SplitStrategy">Id of the Nuclia split strategy used at processing time. If not set, the default strategy was used. Split strategies are defined at the learning configuration api.</param>
public record FieldFile(string? Added, CloudLink? File, string? Language, string? Password, bool External, string? ExtractStrategy, string? SplitStrategy);

/// <summary>FieldID</summary>
/// <param name="FieldType">FieldType</param>
/// <param name="Field">Field</param>
public record FieldID(string FieldType, string Field);

/// <summary>FieldLargeMetadata</summary>
/// <param name="Entities">Entities</param>
/// <param name="Tokens">Tokens</param>
public record FieldLargeMetadata(List<NucliadbModelsExtractedEntity>? Entities, object? Tokens);

/// <summary>FieldLink</summary>
/// <param name="Added">Added</param>
/// <param name="Headers">Headers</param>
/// <param name="Cookies">Cookies</param>
/// <param name="Uri">Uri</param>
/// <param name="Language">Language</param>
/// <param name="Localstorage">Localstorage</param>
/// <param name="CssSelector">CssSelector</param>
/// <param name="Xpath">Xpath</param>
/// <param name="ExtractStrategy">Id of the Nuclia extract strategy used at processing time. If not set, the default strategy was used. Extract strategies are defined at the learning configuration api.</param>
/// <param name="SplitStrategy">Id of the Nuclia split strategy used at processing time. If not set, the default strategy was used. Split strategies are defined at the learning configuration api.</param>
public record FieldLink(string? Added, object? Headers, object? Cookies, string? Uri, string? Language, object? Localstorage, string? CssSelector, string? Xpath, string? ExtractStrategy, string? SplitStrategy);

/// <summary>FieldMetadata</summary>
/// <param name="Links">Links</param>
/// <param name="Paragraphs">Paragraphs</param>
/// <param name="Ner">Ner</param>
/// <param name="Entities">Entities</param>
/// <param name="Classifications">Classifications</param>
/// <param name="LastIndex">LastIndex</param>
/// <param name="LastUnderstanding">LastUnderstanding</param>
/// <param name="LastExtract">LastExtract</param>
/// <param name="LastSummary">LastSummary</param>
/// <param name="LastProcessingStart">LastProcessingStart</param>
/// <param name="Thumbnail">Thumbnail</param>
/// <param name="Language">Language</param>
/// <param name="Summary">Summary</param>
/// <param name="Positions">Positions</param>
/// <param name="Relations">Relations</param>
/// <param name="MimeType">MimeType</param>
public record FieldMetadata(List<string> Links, List<Paragraph> Paragraphs, object Ner, object Entities, List<Classification> Classifications, string? LastIndex, string? LastUnderstanding, string? LastExtract, string? LastSummary, string? LastProcessingStart, CloudLink? Thumbnail, string? Language, string? Summary, object Positions, List<NucliadbModelsMetadataRelation>? Relations, string? MimeType);

/// <summary>Matches fields with a mimetype</summary>
/// <param name="Prop">Prop</param>
/// <param name="Type">Type of the mimetype to match. e.g: In image/jpeg, type is image</param>
/// <param name="Subtype">Type of the mimetype to match. e.g: In image/jpeg, subtype is jpeg.Leave blank to match all mimetype of the type</param>
public record FieldMimetype(string Prop, string Type, string? Subtype);

/// <summary>FieldQuestionAnswers</summary>
/// <param name="QuestionAnswers">QuestionAnswers</param>
/// <param name="SplitQuestionAnswers">SplitQuestionAnswers</param>
/// <param name="DeletedSplits">DeletedSplits</param>
public record FieldQuestionAnswers(QuestionAnswers QuestionAnswers, object? SplitQuestionAnswers, List<string>? DeletedSplits);

/// <summary>FieldText</summary>
/// <param name="Body">Body</param>
/// <param name="Format">Format</param>
/// <param name="Md5">Md5</param>
/// <param name="ExtractStrategy">Id of the Nuclia extract strategy used at processing time. If not set, the default strategy was used. Extract strategies are defined at the learning configuration api.</param>
/// <param name="SplitStrategy">Id of the Nuclia split strategy used at processing time. If not set, the default strategy was used. Split strategies are defined at the learning configuration api.</param>
public record FieldText(string? Body, string? Format, string? Md5, string? ExtractStrategy, string? SplitStrategy);

/// <summary>FileExtractedData</summary>
/// <param name="Language">Language</param>
/// <param name="Md5">Md5</param>
/// <param name="Metadata">Metadata</param>
/// <param name="Nested">Nested</param>
/// <param name="FileGenerated">FileGenerated</param>
/// <param name="FileRowsPreviews">FileRowsPreviews</param>
/// <param name="FilePreview">FilePreview</param>
/// <param name="FilePagesPreviews">FilePagesPreviews</param>
/// <param name="FileThumbnail">FileThumbnail</param>
/// <param name="Field">Field</param>
/// <param name="Icon">Icon</param>
/// <param name="NestedPosition">NestedPosition</param>
/// <param name="NestedListPosition">NestedListPosition</param>
public record FileExtractedData(string? Language, string? Md5, object? Metadata, object? Nested, object? FileGenerated, object? FileRowsPreviews, CloudLink? FilePreview, FilePages? FilePagesPreviews, CloudLink? FileThumbnail, string? Field, string? Icon, object? NestedPosition, object? NestedListPosition);

/// <summary>FileFieldData</summary>
/// <param name="Value">Value</param>
/// <param name="Extracted">Extracted</param>
/// <param name="Error">Error</param>
/// <param name="Status">Status</param>
/// <param name="Errors">Errors</param>
public record FileFieldData(FieldFile? Value, FileFieldExtractedData? Extracted, Error? Error, string? Status, List<Error>? Errors);

/// <summary>FileFieldExtractedData</summary>
/// <param name="Text">Text</param>
/// <param name="Metadata">Metadata</param>
/// <param name="LargeMetadata">LargeMetadata</param>
/// <param name="Vectors">Vectors</param>
/// <param name="QuestionAnswers">QuestionAnswers</param>
/// <param name="File">File</param>
public record FileFieldExtractedData(ExtractedText? Text, FieldComputedMetadata? Metadata, LargeComputedMetadata? LargeMetadata, VectorObject? Vectors, FieldQuestionAnswers? QuestionAnswers, FileExtractedData? File);

/// <summary>FilePages</summary>
/// <param name="Pages">Pages</param>
/// <param name="Positions">Positions</param>
/// <param name="Structures">Structures</param>
public record FilePages(List<CloudLink>? Pages, List<PagePositions>? Positions, List<PageStructure>? Structures);

/// <summary>Filter</summary>
/// <param name="All">All</param>
/// <param name="Any">Any</param>
/// <param name="None">None</param>
/// <param name="NotAll">NotAll</param>
public record Filter(List<string>? All, List<string>? Any, List<string>? None, List<string>? NotAll);

/// <summary>Returns only documents that match this filter expression. Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters  This allows building complex filtering expressions and replaces the following parameters: `fields`, `filters`, `range_*`, `resource_filters`, `keyword_filters`.</summary>
/// <param name="Field">Filter to apply to fields</param>
/// <param name="Paragraph">Filter to apply to each text block</param>
/// <param name="Operator">Operator</param>
public record FilterExpression(object? Field, object? Paragraph, string Operator);

/// <summary>FindField</summary>
/// <param name="Paragraphs">Paragraphs</param>
public record FindField(object Paragraphs);

/// <summary>FindParagraph</summary>
/// <param name="Score">Score</param>
/// <param name="ScoreType">ScoreType</param>
/// <param name="Order">Order</param>
/// <param name="Text">Text</param>
/// <param name="Id">Id</param>
/// <param name="Labels">Labels</param>
/// <param name="Position">Position</param>
/// <param name="FuzzyResult">FuzzyResult</param>
/// <param name="PageWithVisual">This flag informs if the page may have information that has not been extracted</param>
/// <param name="Reference">Reference to the extracted image that represents this paragraph</param>
/// <param name="IsATable">The referenced image of the paragraph is a table</param>
/// <param name="RelevantRelations">Relevant relations from which the paragraph was found, will only be filled if using the Graph RAG Strategy</param>
public record FindParagraph(float Score, string ScoreType, int Order, string Text, string Id, List<string>? Labels, TextPosition? Position, bool FuzzyResult, bool PageWithVisual, string? Reference, bool IsATable, Relations? RelevantRelations);

/// <summary>FindRequest</summary>
/// <param name="AuditMetadata">A dictionary containing optional audit-specific metadata, such as user_id, environment, or other contextual information. This metadata can be leveraged for filtering and analyzing activity logs in future operations. Each key-value pair represents a piece of metadata relevant to the user's request.</param>
/// <param name="Query">The query to search for</param>
/// <param name="FilterExpression">Returns only documents that match this filter expression.Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters This allows building complex filtering expressions and replaces the following parameters:`fields`, `filters`, `range_*`, `resource_filters`, `keyword_filters`.</param>
/// <param name="Fields">The list of fields to search in. For instance: `a/title` to search only on title field. For more details on filtering by field, see: https://docs.nuclia.dev/docs/rag/advanced/search/#search-in-a-specific-field.</param>
/// <param name="Filters">The list of filters to apply. Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters</param>
/// <param name="TopK">The number of results search should return. The maximum number of results allowed is 200.</param>
/// <param name="MinScore">Minimum score to filter search results. Results with a lower score will be ignored. Accepts either a float or a dictionary with the minimum scores for the bm25 and vector indexes. If a float is provided, it is interpreted as the minimum score for vector index search.</param>
/// <param name="RangeCreationStart">Resources created before this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</param>
/// <param name="RangeCreationEnd">Resources created after this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</param>
/// <param name="RangeModificationStart">Resources modified before this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</param>
/// <param name="RangeModificationEnd">Resources modified after this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</param>
/// <param name="Debug">If set, the response will include some extra metadata for debugging purposes, like the list of queried nodes.</param>
/// <param name="Highlight">If set to true, the query terms will be highlighted in the results between <mark>...</mark> tags</param>
/// <param name="Show">Controls which types of metadata are serialized on resources of search results</param>
/// <param name="FieldTypeFilter">Define which field types are serialized on resources of search results</param>
/// <param name="Extracted">[Deprecated] Please use GET resource endpoint instead to get extracted metadata</param>
/// <param name="Vector">The vector to perform the search with. If not provided, NucliaDB will use Nuclia Predict API to create the vector off from the query.</param>
/// <param name="Vectorset">Vectors index to perform the search in. If not provided, NucliaDB will use the default one</param>
/// <param name="WithDuplicates">Whether to return duplicate paragraphs on the same document</param>
/// <param name="WithSynonyms">Whether to return matches for custom knowledge box synonyms of the query terms. Note: only supported for `keyword` and `fulltext` search options.</param>
/// <param name="Autofilter">If set to true, the search will automatically add filters to the query. For example, it will filter results containing the entities detected in the query</param>
/// <param name="ResourceFilters">List of resource ids to filter search results for. Only paragraphs from the specified resources will be returned.</param>
/// <param name="Security">Security metadata for the request. If not provided, the search request is done without the security lookup phase.</param>
/// <param name="ShowHidden">If set to false (default), excludes hidden resources from search</param>
/// <param name="Rephrase">Rephrase the query for a more efficient retrieval. This will consume LLM tokens and make the request slower.</param>
/// <param name="RephrasePrompt">Rephrase prompt given to the generative model responsible for rephrasing the query for a more effective retrieval step. This is only used if the `rephrase` flag is set to true in the request. If not specified, Nuclia's default prompt is used. It must include the {question} placeholder. The placeholder will be replaced with the original question</param>
/// <param name="QueryImage">Image that will be used together with the query text for retrieval.</param>
/// <param name="GraphQuery">Query for the knowledge graph. Paths (node-relation-node) extracted from a paragraph_id will be used to extend the results</param>
/// <param name="Features">List of search features to use. Each value corresponds to a lookup into on of the different indexes</param>
/// <param name="RankFusion">Rank fusion algorithm to use to merge results from multiple retrievers (keyword, semantic)</param>
/// <param name="Reranker">Reranker let you specify which method you want to use to rerank your results at the end of retrieval</param>
/// <param name="KeywordFilters">List of keyword filter expressions to apply to the retrieval step. The text block search will only be performed on the documents that contain the specified keywords. The filters are case-insensitive, and only alphanumeric characters and spaces are allowed. Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters</param>
/// <param name="SearchConfiguration">Load find parameters from this configuration. Parameters in the request override parameters from the configuration.</param>
/// <param name="GenerativeModel">The generative model used to rephrase the query. If not provided, the model configured for the Knowledge Box is used.</param>
public record FindRequest(object? AuditMetadata, string Query, FilterExpression? FilterExpression, List<string> Fields, List<string>? Filters, int TopK, float? MinScore, string? RangeCreationStart, string? RangeCreationEnd, string? RangeModificationStart, string? RangeModificationEnd, bool Debug, bool Highlight, List<string> Show, List<string> FieldTypeFilter, List<string> Extracted, List<double>? Vector, string? Vectorset, bool WithDuplicates, bool WithSynonyms, bool Autofilter, List<string> ResourceFilters, RequestSecurity? Security, bool ShowHidden, bool Rephrase, string? RephrasePrompt, Image? QueryImage, object? GraphQuery, List<string> Features, string? RankFusion, string? Reranker, List<string>? KeywordFilters, string? SearchConfiguration, string? GenerativeModel);

/// <summary>FindResource</summary>
/// <param name="Id">Id</param>
/// <param name="Slug">Slug</param>
/// <param name="Title">Title</param>
/// <param name="Summary">Summary</param>
/// <param name="Icon">Icon</param>
/// <param name="Thumbnail">Thumbnail</param>
/// <param name="Metadata">Metadata</param>
/// <param name="Usermetadata">Usermetadata</param>
/// <param name="Fieldmetadata">Fieldmetadata</param>
/// <param name="Computedmetadata">Computedmetadata</param>
/// <param name="Created">Created</param>
/// <param name="Modified">Modified</param>
/// <param name="LastSeqid">LastSeqid</param>
/// <param name="LastAccountSeq">LastAccountSeq</param>
/// <param name="Queue">Queue</param>
/// <param name="Hidden">Hidden</param>
/// <param name="Origin">Origin</param>
/// <param name="Extra">Extra</param>
/// <param name="Relations">Relations</param>
/// <param name="Data">Data</param>
/// <param name="Security">Resource security metadata</param>
/// <param name="Fields">Fields</param>
public record FindResource(string Id, string? Slug, string? Title, string? Summary, string? Icon, string? Thumbnail, Metadata? Metadata, UserMetadata? Usermetadata, List<UserFieldMetadata>? Fieldmetadata, ComputedMetadata? Computedmetadata, string? Created, string? Modified, int? LastSeqid, int? LastAccountSeq, string? Queue, bool? Hidden, Origin? Origin, Extra? Extra, List<RelationOutput>? Relations, ResourceData? Data, ResourceSecurity? Security, object Fields);

/// <summary>FullResourceApplyTo</summary>
/// <param name="Exclude">Resources from matches containing any of these labels won't expand to the full resource. This may be useful to exclude long and not interesting resources and expend less tokens</param>
public record FullResourceApplyTo(List<string> Exclude);

/// <summary>FullResourceStrategy</summary>
/// <param name="Name">Name</param>
/// <param name="Count">Maximum number of full documents to retrieve. If not specified, all matching documents are retrieved.</param>
/// <param name="IncludeRemainingTextBlocks">Whether to include the remaining text blocks after the maximum number of resources has been reached.</param>
/// <param name="ApplyTo">Define which resources to exclude from serialization</param>
public record FullResourceStrategy(string Name, int? Count, bool IncludeRemainingTextBlocks, FullResourceApplyTo? ApplyTo);

/// <summary>GenericFieldData</summary>
/// <param name="Value">Value</param>
/// <param name="Extracted">Extracted</param>
/// <param name="Error">Error</param>
/// <param name="Status">Status</param>
/// <param name="Errors">Errors</param>
public record GenericFieldData(string? Value, TextFieldExtractedData? Extracted, Error? Error, string? Status, List<Error>? Errors);

/// <summary>Returns only relations from documents that match this filter expression. Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters</summary>
/// <param name="Field">Filter to apply to fields</param>
public record GraphFilterExpression(object Field);

/// <summary>GraphNodeInput</summary>
/// <param name="Value">Value</param>
/// <param name="Match">Match</param>
/// <param name="Type">Type</param>
/// <param name="Group">Group</param>
public record GraphNodeInput(string? Value, string Match, string? Type, string? Group);

/// <summary>GraphNodeOutput</summary>
/// <param name="Value">Value</param>
/// <param name="Type">Type</param>
/// <param name="Group">Group</param>
public record GraphNodeOutput(string Value, string Type, string Group);

/// <summary>GraphNodesSearchRequest</summary>
/// <param name="TopK">TopK</param>
/// <param name="FilterExpression">Returns only relations from documents that match this filter expression.Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters</param>
/// <param name="Security">Security metadata for the request. If not provided, the search request is done without the security lookup phase.</param>
/// <param name="ShowHidden">If set to false (default), excludes hidden resources from search</param>
/// <param name="Query">Query</param>
public record GraphNodesSearchRequest(int TopK, GraphFilterExpression? FilterExpression, RequestSecurity? Security, bool ShowHidden, object Query);

/// <summary>GraphNodesSearchResponse</summary>
/// <param name="Nodes">Nodes</param>
public record GraphNodesSearchResponse(List<GraphNodeOutput> Nodes);

/// <summary>GraphPathInput</summary>
/// <param name="Prop">Prop</param>
/// <param name="Source">Source</param>
/// <param name="Relation">Relation</param>
/// <param name="Destination">Destination</param>
/// <param name="Undirected">Undirected</param>
public record GraphPathInput(string Prop, GraphNodeInput? Source, GraphRelationInput? Relation, GraphNodeInput? Destination, bool Undirected);

/// <summary>GraphPathOutput</summary>
/// <param name="Source">Source</param>
/// <param name="Relation">Relation</param>
/// <param name="Destination">Destination</param>
public record GraphPathOutput(GraphNodeOutput Source, GraphRelationOutput Relation, GraphNodeOutput Destination);

/// <summary>GraphRelationInput</summary>
/// <param name="Label">Label</param>
/// <param name="Type">Type</param>
public record GraphRelationInput(string? Label, string? Type);

/// <summary>GraphRelationOutput</summary>
/// <param name="Label">Label</param>
/// <param name="Type">Type</param>
public record GraphRelationOutput(string Label, string Type);

/// <summary>GraphRelationsSearchRequest</summary>
/// <param name="TopK">TopK</param>
/// <param name="FilterExpression">Returns only relations from documents that match this filter expression.Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters</param>
/// <param name="Security">Security metadata for the request. If not provided, the search request is done without the security lookup phase.</param>
/// <param name="ShowHidden">If set to false (default), excludes hidden resources from search</param>
/// <param name="Query">Query</param>
public record GraphRelationsSearchRequest(int TopK, GraphFilterExpression? FilterExpression, RequestSecurity? Security, bool ShowHidden, object Query);

/// <summary>GraphRelationsSearchResponse</summary>
/// <param name="Relations">Relations</param>
public record GraphRelationsSearchResponse(List<GraphRelationOutput> Relations);

/// <summary>GraphSearchRequest</summary>
/// <param name="TopK">TopK</param>
/// <param name="FilterExpression">Returns only relations from documents that match this filter expression.Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters</param>
/// <param name="Security">Security metadata for the request. If not provided, the search request is done without the security lookup phase.</param>
/// <param name="ShowHidden">If set to false (default), excludes hidden resources from search</param>
/// <param name="Query">Query</param>
public record GraphSearchRequest(int TopK, GraphFilterExpression? FilterExpression, RequestSecurity? Security, bool ShowHidden, object Query);

/// <summary>GraphSearchResponse</summary>
/// <param name="Paths">Paths</param>
public record GraphSearchResponse(List<GraphPathOutput> Paths);

/// <summary>This strategy retrieves context pieces by exploring the Knowledge Graph, starting from the entities present in the query. It works best if the Knowledge Box has a user-defined Graph Extraction agent enabled.</summary>
/// <param name="Name">Name</param>
/// <param name="Hops">Number of hops to take when exploring the graph for relevant context. For example, - hops=1 will explore the neighbors of the starting entities. - hops=2 will explore the neighbors of the neighbors of the starting entities. And so on. Bigger values will discover more intricate relationships but will also take more time to compute.</param>
/// <param name="TopK">Number of relationships to keep after each hop after ranking them by relevance to the query. This number correlates to more paragraphs being sent as context. If not set, this number will be set to 30 if `relation_text_as_paragraphs` is set to false or 200 if `relation_text_as_paragraphs` is set to true.</param>
/// <param name="ExcludeProcessorRelations">If set to true, only relationships extracted from a graph extraction agent are considered for context expansion.</param>
/// <param name="RelationTextAsParagraphs">If set to true, the text of the relationships is to create context paragraphs, this enables to use bigger top K values without running into the generative model's context limits. If set to false, the paragraphs that contain the relationships are used as context.</param>
/// <param name="RelationRanking">RelationRanking</param>
/// <param name="QueryEntityDetection">QueryEntityDetection</param>
/// <param name="Weight">Weight of the graph strategy in the context. The weight is used to scale the results of the strategy before adding them to the context.The weight should be a positive number.</param>
public record GraphStrategy(string Name, int Hops, int TopK, bool ExcludeProcessorRelations, bool RelationTextAsParagraphs, string RelationRanking, string QueryEntityDetection, float Weight);

/// <summary>HierarchyResourceStrategy</summary>
/// <param name="Name">Name</param>
/// <param name="Count">Number of extra characters that are added to each matching paragraph when adding to the context.</param>
public record HierarchyResourceStrategy(string Name, int Count);

/// <summary>Image</summary>
/// <param name="ContentType">ContentType</param>
/// <param name="B64encoded">B64encoded</param>
public record Image(string ContentType, string B64encoded);

/// <summary>Matches all fields that contain a keyword</summary>
/// <param name="Prop">Prop</param>
/// <param name="Word">Keyword to find</param>
public record Keyword(string Prop, string Word);

/// <summary>Matches paragraphs of a certain kind</summary>
/// <param name="Prop">Prop</param>
/// <param name="KindValue">KindValue</param>
public record Kind(string Prop, string KindValue);

/// <summary>KnowledgeboxCounters</summary>
/// <param name="Resources">Resources</param>
/// <param name="Paragraphs">Paragraphs</param>
/// <param name="Fields">Fields</param>
/// <param name="Sentences">Sentences</param>
/// <param name="Shards">Shards</param>
/// <param name="IndexSize">IndexSize</param>
public record KnowledgeboxCounters(int Resources, int Paragraphs, int Fields, int Sentences, List<string>? Shards, float IndexSize);

/// <summary>Find on knowledgebox results</summary>
/// <param name="Resources">Resources</param>
/// <param name="Relations">Relations</param>
/// <param name="Query">Query</param>
/// <param name="RephrasedQuery">RephrasedQuery</param>
/// <param name="Total">Total</param>
/// <param name="PageNumber">Pagination will be deprecated, please, refer to `top_k` in the request</param>
/// <param name="PageSize">Pagination will be deprecated, please, refer to `top_k` in the request</param>
/// <param name="NextPage">Pagination will be deprecated, please, refer to `top_k` in the request</param>
/// <param name="Nodes">List of nodes queried in the search</param>
/// <param name="Shards">The list of shard replica ids used for the search.</param>
/// <param name="Autofilters">List of filters automatically applied to the search query</param>
/// <param name="MinScore">The minimum scores that have been used for the search operation.</param>
/// <param name="BestMatches">List of ids of best matching paragraphs. The list is sorted by decreasing relevance (most relevant first).</param>
/// <param name="Metrics">Metrics information about the search operation. The metadata included in this field is subject to change and should not be used in production. This is only available if the `debug` parameter is set to true in the request.</param>
public record KnowledgeboxFindResults(object Resources, Relations? Relations, string? Query, string? RephrasedQuery, int Total, int PageNumber, int PageSize, bool NextPage, List<object>? Nodes, List<string>? Shards, List<string> Autofilters, float? MinScore, List<string> BestMatches, object? Metrics);

/// <summary>Search on knowledgebox results</summary>
/// <param name="Resources">Resources</param>
/// <param name="Sentences">Sentences</param>
/// <param name="Paragraphs">Paragraphs</param>
/// <param name="Fulltext">Fulltext</param>
/// <param name="Relations">Relations</param>
/// <param name="Nodes">Nodes</param>
/// <param name="Shards">Shards</param>
/// <param name="Autofilters">List of filters automatically applied to the search query</param>
public record KnowledgeboxSearchResults(object Resources, Sentences? Sentences, Paragraphs? Paragraphs, Resources? Fulltext, Relations? Relations, List<object>? Nodes, List<string>? Shards, List<string> Autofilters);

/// <summary>Suggest on resource results</summary>
/// <param name="Paragraphs">Paragraphs</param>
/// <param name="Entities">Entities</param>
/// <param name="Shards">Shards</param>
public record KnowledgeboxSuggestResults(Paragraphs? Paragraphs, RelatedEntities? Entities, List<string>? Shards);

/// <summary>Matches fields/paragraphs with a label (or labelset)</summary>
/// <param name="Prop">Prop</param>
/// <param name="Labelset">The labelset to match</param>
/// <param name="LabelValue">The label to match. If blank, matches all labels in the given labelset</param>
public record Label(string Prop, string Labelset, string? LabelValue);

/// <summary>Matches the language of the field</summary>
/// <param name="Prop">Prop</param>
/// <param name="OnlyPrimary">Match only the primary language of the document. By default, matches any language that appears in the document</param>
/// <param name="LanguageValue">The code of the language to match, e.g: en</param>
public record Language(string Prop, bool OnlyPrimary, string LanguageValue);

/// <summary>LargeComputedMetadata</summary>
/// <param name="Metadata">Metadata</param>
/// <param name="SplitMetadata">SplitMetadata</param>
/// <param name="DeletedSplits">DeletedSplits</param>
public record LargeComputedMetadata(FieldLargeMetadata? Metadata, object? SplitMetadata, List<string>? DeletedSplits);

/// <summary>LinkExtractedData</summary>
/// <param name="Date">Date</param>
/// <param name="Language">Language</param>
/// <param name="Title">Title</param>
/// <param name="Metadata">Metadata</param>
/// <param name="LinkThumbnail">LinkThumbnail</param>
/// <param name="LinkPreview">LinkPreview</param>
/// <param name="Field">Field</param>
/// <param name="LinkImage">LinkImage</param>
/// <param name="Description">Description</param>
/// <param name="Type">Type</param>
/// <param name="Embed">Embed</param>
/// <param name="FileGenerated">FileGenerated</param>
public record LinkExtractedData(string? Date, string? Language, string? Title, object? Metadata, CloudLink? LinkThumbnail, CloudLink? LinkPreview, string? Field, CloudLink? LinkImage, string? Description, string? Type, string? Embed, object? FileGenerated);

/// <summary>LinkFieldData</summary>
/// <param name="Value">Value</param>
/// <param name="Extracted">Extracted</param>
/// <param name="Error">Error</param>
/// <param name="Status">Status</param>
/// <param name="Errors">Errors</param>
public record LinkFieldData(FieldLink? Value, LinkFieldExtractedData? Extracted, Error? Error, string? Status, List<Error>? Errors);

/// <summary>LinkFieldExtractedData</summary>
/// <param name="Text">Text</param>
/// <param name="Metadata">Metadata</param>
/// <param name="LargeMetadata">LargeMetadata</param>
/// <param name="Vectors">Vectors</param>
/// <param name="QuestionAnswers">QuestionAnswers</param>
/// <param name="Link">Link</param>
public record LinkFieldExtractedData(ExtractedText? Text, FieldComputedMetadata? Metadata, LargeComputedMetadata? LargeMetadata, VectorObject? Vectors, FieldQuestionAnswers? QuestionAnswers, LinkExtractedData? Link);

/// <summary>MaxTokens</summary>
/// <param name="Context">Use to limit the amount of tokens used in the LLM context</param>
/// <param name="Answer">Use to limit the amount of tokens used in the LLM answer</param>
public record MaxTokens(int? Context, int? Answer);

/// <summary>Metadata</summary>
/// <param name="MetadataValue">MetadataValue</param>
/// <param name="Language">Language</param>
/// <param name="Languages">Languages</param>
/// <param name="Status">Status</param>
public record Metadata(object MetadataValue, string? Language, List<string>? Languages, string Status);

/// <summary>RAG strategy to enrich the context with metadata of the matching paragraphs or its resources. This strategy can be combined with any of the other strategies.</summary>
/// <param name="Name">Name</param>
/// <param name="Types">List of resource metadata types to add to the context.   - 'origin': origin metadata of the resource.   - 'classification_labels': classification labels of the resource.   - 'ner': Named Entity Recognition entities detected for the resource.   - 'extra_metadata': extra metadata of the resource.  Types for which the metadata is not found at the resource are ignored and not added to the context.</param>
public record MetadataExtensionStrategy(string Name, List<string> Types);

/// <summary>MinScore</summary>
/// <param name="Semantic">Minimum semantic similarity score used to filter vector index search. If not specified, the default minimum score of the semantic model associated to the Knowledge Box will be used. Check out the documentation for more information on how to use this parameter: https://docs.nuclia.dev/docs/rag/advanced/search#minimum-score</param>
/// <param name="Bm25">Minimum score used to filter bm25 index search. Check out the documentation for more information on how to use this parameter: https://docs.nuclia.dev/docs/rag/advanced/search#minimum-score</param>
public record MinScore(float? Semantic, float Bm25);

/// <summary>NeighbouringParagraphsStrategy</summary>
/// <param name="Name">Name</param>
/// <param name="Before">Number of previous neighbouring paragraphs to add to the context, for each matching paragraph in the retrieval step.</param>
/// <param name="After">Number of following neighbouring paragraphs to add to the context, for each matching paragraph in the retrieval step.</param>
public record NeighbouringParagraphsStrategy(string Name, int Before, int After);

/// <summary>NestedListPosition</summary>
/// <param name="Positions">Positions</param>
public record NestedListPosition(List<NestedPosition> Positions);

/// <summary>NestedPosition</summary>
/// <param name="Start">Start</param>
/// <param name="End">End</param>
/// <param name="Page">Page</param>
public record NestedPosition(int? Start, int? End, int? Page);

/// <summary>NewTextField</summary>
/// <param name="TextField">TextField</param>
/// <param name="Destination">Destination</param>
public record NewTextField(FieldText TextField, string Destination);

/// <summary>NotFieldFilterExpression</summary>

public record NotFieldFilterExpression();

/// <summary>NotGraphNodesQuery</summary>
/// <param name="Operand">Operand</param>
public record NotGraphNodesQuery(object Operand);

/// <summary>NotGraphPathQuery</summary>

public record NotGraphPathQuery();

/// <summary>NotGraphRelationsQuery</summary>
/// <param name="Operand">Operand</param>
public record NotGraphRelationsQuery(object Operand);

/// <summary>NotParagraphFilterExpression</summary>

public record NotParagraphFilterExpression();

/// <summary>NotResourceFilterExpression</summary>
/// <param name="Operand">Operand</param>
public record NotResourceFilterExpression(object Operand);

/// <summary>OrFieldFilterExpression</summary>

public record OrFieldFilterExpression();

/// <summary>OrGraphNodesQuery</summary>
/// <param name="Operands">Operands</param>
public record OrGraphNodesQuery(List<object> Operands);

/// <summary>OrGraphPathQuery</summary>

public record OrGraphPathQuery();

/// <summary>OrGraphRelationsQuery</summary>
/// <param name="Operands">Operands</param>
public record OrGraphRelationsQuery(List<object> Operands);

/// <summary>OrParagraphFilterExpression</summary>

public record OrParagraphFilterExpression();

/// <summary>OrResourceFilterExpression</summary>
/// <param name="Operands">Operands</param>
public record OrResourceFilterExpression(List<object> Operands);

/// <summary>Origin</summary>
/// <param name="SourceId">SourceId</param>
/// <param name="Url">Url</param>
/// <param name="Created">Created</param>
/// <param name="Modified">Modified</param>
/// <param name="Metadata">Generic metadata from the resource at the origin system. It can later be used for filtering on search endpoints with '/origin.metadata/{key}/{value}'</param>
/// <param name="Tags">Resource tags about the origin system. It can later be used for filtering on search endpoints with '/origin.tags/{tag}'</param>
/// <param name="Collaborators">Collaborators</param>
/// <param name="Filename">Filename</param>
/// <param name="Related">Related</param>
/// <param name="Path">Path of the original resource. Typically used to store folder structure information of the resource at the origin system. It can be later used for filtering on search endpoints with '/origin.path/{path}'</param>
/// <param name="Source">Source</param>
public record Origin(string? SourceId, string? Url, string? Created, string? Modified, object Metadata, List<string> Tags, List<string> Collaborators, string? Filename, List<string> Related, string? Path, string? Source);

/// <summary>Matches the origin collaborators</summary>
/// <param name="Prop">Prop</param>
/// <param name="Collaborator">Collaborator</param>
public record OriginCollaborator(string Prop, string Collaborator);

/// <summary>Matches metadata from the origin</summary>
/// <param name="Prop">Prop</param>
/// <param name="Field">Metadata field</param>
/// <param name="Value">Value of the metadata field. If blank, matches any document with the given metadata field set (to any value)</param>
public record OriginMetadata(string Prop, string Field, string? Value);

/// <summary>Matches the origin path</summary>
/// <param name="Prop">Prop</param>
/// <param name="Prefix">Prefix of the path, matches all paths under this prefixe.g: `prefix=/dir/` matches `/dir` and `/dir/a/b` but not `/dirrrr`</param>
public record OriginPath(string Prop, string? Prefix);

/// <summary>Matches the origin source id</summary>
/// <param name="Prop">Prop</param>
/// <param name="Id">Source ID</param>
public record OriginSource(string Prop, string? Id);

/// <summary>Matches all fields with a given origin tag</summary>
/// <param name="Prop">Prop</param>
/// <param name="Tag">The tag to match</param>
public record OriginTag(string Prop, string Tag);

/// <summary>PageImageStrategy</summary>
/// <param name="Name">Name</param>
/// <param name="Count">Maximum number of images to retrieve from the page. By default, at most 5 images are retrieved.</param>
public record PageImageStrategy(string Name, int? Count);

/// <summary>PageInformation</summary>
/// <param name="Page">Page</param>
/// <param name="PageWithVisual">PageWithVisual</param>
public record PageInformation(int? Page, bool? PageWithVisual);

/// <summary>PagePositions</summary>
/// <param name="Start">Start</param>
/// <param name="End">End</param>
public record PagePositions(int? Start, int? End);

/// <summary>PageStructure</summary>
/// <param name="Page">Page</param>
/// <param name="Tokens">Tokens</param>
public record PageStructure(PageStructurePage Page, List<PageStructureToken> Tokens);

/// <summary>PageStructurePage</summary>
/// <param name="Width">Width</param>
/// <param name="Height">Height</param>
public record PageStructurePage(int Width, int Height);

/// <summary>PageStructureToken</summary>
/// <param name="X">X</param>
/// <param name="Y">Y</param>
/// <param name="Width">Width</param>
/// <param name="Height">Height</param>
/// <param name="Text">Text</param>
/// <param name="Line">Line</param>
public record PageStructureToken(float X, float Y, float Width, float Height, string Text, float Line);

/// <summary>ParagraphAnnotation</summary>
/// <param name="Classifications">Classifications</param>
/// <param name="Key">Key</param>
public record ParagraphAnnotation(List<UserClassification> Classifications, string Key);

/// <summary>ParagraphImageStrategy</summary>
/// <param name="Name">Name</param>
public record ParagraphImageStrategy(string Name);

/// <summary>ParagraphRelations</summary>
/// <param name="Parents">Parents</param>
/// <param name="Siblings">Siblings</param>
/// <param name="Replacements">Replacements</param>
public record ParagraphRelations(List<string> Parents, List<string> Siblings, List<string> Replacements);

/// <summary>Paragraphs</summary>
/// <param name="Results">Results</param>
/// <param name="Facets">Facets</param>
/// <param name="Query">Query</param>
/// <param name="Total">Total</param>
/// <param name="PageNumber">PageNumber</param>
/// <param name="PageSize">PageSize</param>
/// <param name="NextPage">NextPage</param>
/// <param name="MinScore">Minimum bm25 score used to filter bm25 index search. Results with a lower score have been ignored.</param>
public record Paragraphs(List<NucliadbModelsSearchParagraph> Results, object? Facets, string? Query, int Total, int PageNumber, int PageSize, bool NextPage, float MinScore);

/// <summary>Position</summary>
/// <param name="Start">Start</param>
/// <param name="End">End</param>
public record Position(int Start, int End);

/// <summary>Positions</summary>
/// <param name="Position">Position</param>
/// <param name="Entity">Entity</param>
public record Positions(List<Position> Position, string Entity);

/// <summary>This strategy allows to run a set of queries before the main query and add the results to the context. It allows to give more importance to some queries over others by setting the weight of each query. The weight of the main query can also be set with the `main_query_weight` parameter.</summary>
/// <param name="Name">Name</param>
/// <param name="Queries">List of queries to run before the main query. The results are added to the context with the specified weights for each query. There is a limit of 10 prequeries per request.</param>
/// <param name="MainQueryWeight">Weight of the main query in the context. Use this to control the importance of the main query in the context.</param>
public record PreQueriesStrategy(string Name, List<PreQuery> Queries, float MainQueryWeight);

/// <summary>PreQuery</summary>
/// <param name="Request">Request</param>
/// <param name="Weight">Weight of the prequery in the context. The weight is used to scale the results of the prequery before adding them to the context.The weight should be a positive number, and they are normalized so that the sum of all weights for all prequeries is 1.</param>
/// <param name="Id">Identifier of the prequery. If not specified, it is autogenerated based on the index of the prequery in the list (prequery_0, prequery_1, ...).</param>
/// <param name="Prefilter">If set to true, the prequery results are used to filter the scope of the remaining queries. The resources of the most relevant paragraphs of the prefilter queries are used as resource filters for the main query and other prequeries with the prefilter flag set to false.</param>
public record PreQuery(FindRequest Request, float Weight, string? Id, bool Prefilter);

/// <summary>PredictReranker</summary>
/// <param name="Name">Name</param>
/// <param name="Window">Number of elements reranker will use. Window must be greater or equal to top_k. Greater values will improve results at cost of retrieval and reranking time. By default, this reranker uses a default of 2 times top_k</param>
public record PredictReranker(string Name, int? Window);

/// <summary>Question</summary>
/// <param name="Text">Text</param>
/// <param name="Language">Language</param>
/// <param name="IdsParagraphs">IdsParagraphs</param>
public record Question(string Text, string? Language, List<string> IdsParagraphs);

/// <summary>QuestionAnswer</summary>
/// <param name="Question">Question</param>
/// <param name="Answers">Answers</param>
public record QuestionAnswer(Question Question, List<Answer> Answers);

/// <summary>QuestionAnswerAnnotation</summary>
/// <param name="QuestionAnswer">QuestionAnswer</param>
/// <param name="CancelledByUser">CancelledByUser</param>
public record QuestionAnswerAnnotation(QuestionAnswer QuestionAnswer, bool CancelledByUser);

/// <summary>QuestionAnswers</summary>
/// <param name="QuestionAnswer">QuestionAnswer</param>
public record QuestionAnswers(List<QuestionAnswer> QuestionAnswer);

/// <summary>Reasoning</summary>
/// <param name="Display">Whether to display the reasoning steps in the response.</param>
/// <param name="Effort">Level of reasoning effort. Used by OpenAI models to control the depth of reasoning. This parameter will be automatically mapped to budget_tokens if the chosen model does not support effort.</param>
/// <param name="BudgetTokens">Token budget for reasoning. Used by Anthropic or Google models to limit the number of tokens used for reasoning. This parameter will be automatically mapped to effort if the chosen model does not support budget_tokens.</param>
public record Reasoning(bool Display, string Effort, int BudgetTokens);

/// <summary>ReciprocalRankFusion</summary>
/// <param name="Name">Name</param>
/// <param name="K">k parameter changes the influence top-ranked and lower-ranked elements have. Research has shown that 60 is a performant value across datasets</param>
/// <param name="Window">Number of elements for retrieval to do RRF. Window must be greater or equal to top_k. Greater values will increase probability of multi match at cost of retrieval time</param>
/// <param name="Boosting">Boosting</param>
public record ReciprocalRankFusion(string Name, float K, int? Window, ReciprocalRankFusionWeights Boosting);

/// <summary>ReciprocalRankFusionWeights</summary>
/// <param name="Keyword">Keyword</param>
/// <param name="Semantic">Semantic</param>
public record ReciprocalRankFusionWeights(float Keyword, float Semantic);

/// <summary>RelatedEntities</summary>
/// <param name="Total">Total</param>
/// <param name="Entities">Entities</param>
public record RelatedEntities(int Total, List<RelatedEntity> Entities);

/// <summary>RelatedEntity</summary>
/// <param name="Family">Family</param>
/// <param name="Value">Value</param>
public record RelatedEntity(string Family, string Value);

/// <summary>RelationInput</summary>
/// <param name="Prop">Prop</param>
/// <param name="Label">Label</param>
/// <param name="Type">Type</param>
public record RelationInput(string Prop, string? Label, string? Type);

/// <summary>RelationOutput</summary>
/// <param name="Relation">Relation</param>
/// <param name="Label">Label</param>
/// <param name="Metadata">Metadata</param>
/// <param name="From">From</param>
/// <param name="To">To</param>
public record RelationOutput(string Relation, string? Label, RelationMetadata? Metadata, RelationEntity? From, RelationEntity To);

/// <summary>RelationEntity</summary>
/// <param name="Value">Value</param>
/// <param name="Type">Type</param>
/// <param name="Group">Group</param>
public record RelationEntity(string Value, string Type, string? Group);

/// <summary>RelationMetadata</summary>
/// <param name="ParagraphId">ParagraphId</param>
/// <param name="SourceStart">SourceStart</param>
/// <param name="SourceEnd">SourceEnd</param>
/// <param name="ToStart">ToStart</param>
/// <param name="ToEnd">ToEnd</param>
/// <param name="DataAugmentationTaskId">DataAugmentationTaskId</param>
public record RelationMetadata(string? ParagraphId, int? SourceStart, int? SourceEnd, int? ToStart, int? ToEnd, string? DataAugmentationTaskId);

/// <summary>Relations</summary>
/// <param name="Entities">Entities</param>
public record Relations(object Entities);

/// <summary>Representation</summary>
/// <param name="IsATable">IsATable</param>
/// <param name="ReferenceFile">ReferenceFile</param>
public record Representation(bool? IsATable, string? ReferenceFile);

/// <summary>Security metadata for the search request</summary>
/// <param name="Groups">List of group ids to do the request with.</param>
public record RequestSecurity(List<string> Groups);

/// <summary>Matches all fields of a resource given its id or slug</summary>
/// <param name="Prop">Prop</param>
/// <param name="Id">UUID of the resource to match</param>
/// <param name="Slug">Slug of the resource to match</param>
public record ResourceInput(string Prop, string? Id, string? Slug);

/// <summary>ResourceOutput</summary>
/// <param name="Id">Id</param>
/// <param name="Slug">Slug</param>
/// <param name="Title">Title</param>
/// <param name="Summary">Summary</param>
/// <param name="Icon">Icon</param>
/// <param name="Thumbnail">Thumbnail</param>
/// <param name="Metadata">Metadata</param>
/// <param name="Usermetadata">Usermetadata</param>
/// <param name="Fieldmetadata">Fieldmetadata</param>
/// <param name="Computedmetadata">Computedmetadata</param>
/// <param name="Created">Created</param>
/// <param name="Modified">Modified</param>
/// <param name="LastSeqid">LastSeqid</param>
/// <param name="LastAccountSeq">LastAccountSeq</param>
/// <param name="Queue">Queue</param>
/// <param name="Hidden">Hidden</param>
/// <param name="Origin">Origin</param>
/// <param name="Extra">Extra</param>
/// <param name="Relations">Relations</param>
/// <param name="Data">Data</param>
/// <param name="Security">Resource security metadata</param>
public record ResourceOutput(string Id, string? Slug, string? Title, string? Summary, string? Icon, string? Thumbnail, Metadata? Metadata, UserMetadata? Usermetadata, List<UserFieldMetadata>? Fieldmetadata, ComputedMetadata? Computedmetadata, string? Created, string? Modified, int? LastSeqid, int? LastAccountSeq, string? Queue, bool? Hidden, Origin? Origin, Extra? Extra, List<RelationOutput>? Relations, ResourceData? Data, ResourceSecurity? Security);

/// <summary>ResourceAgentsRequest</summary>
/// <param name="Filters">Filters to apply to the agents. If None, all curently configured agents are applied.</param>
/// <param name="AgentIds">AgentIds</param>
public record ResourceAgentsRequest(List<AgentsFilter>? Filters, List<string>? AgentIds);

/// <summary>ResourceAgentsResponse</summary>
/// <param name="Results">Results</param>
public record ResourceAgentsResponse(object Results);

/// <summary>ResourceData</summary>
/// <param name="Texts">Texts</param>
/// <param name="Files">Files</param>
/// <param name="Links">Links</param>
/// <param name="Conversations">Conversations</param>
/// <param name="Generics">Generics</param>
public record ResourceData(object? Texts, object? Files, object? Links, object? Conversations, object? Generics);

/// <summary>Matches resources with a mimetype.  The mimetype of a resource can be assigned independently of the mimetype of its fields. In resources with multiple fields, you may prefer to use `field_mimetype`</summary>
/// <param name="Prop">Prop</param>
/// <param name="Type">Type of the mimetype to match. e.g: In image/jpeg, type is image</param>
/// <param name="Subtype">Type of the mimetype to match. e.g: In image/jpeg, subtype is jpeg.Leave blank to match all mimetype of the type</param>
public record ResourceMimetype(string Prop, string Type, string? Subtype);

/// <summary>ResourceResult</summary>
/// <param name="Score">Score</param>
/// <param name="Rid">Rid</param>
/// <param name="FieldType">FieldType</param>
/// <param name="Field">Field</param>
/// <param name="Labels">Labels</param>
public record ResourceResult(float? Score, string Rid, string FieldType, string Field, List<string>? Labels);

/// <summary>Search on resource results</summary>
/// <param name="Sentences">Sentences</param>
/// <param name="Paragraphs">Paragraphs</param>
/// <param name="Relations">Relations</param>
/// <param name="Nodes">Nodes</param>
/// <param name="Shards">Shards</param>
public record ResourceSearchResults(Sentences? Sentences, Paragraphs? Paragraphs, Relations? Relations, List<object>? Nodes, List<string>? Shards);

/// <summary>Security metadata for the resource</summary>
/// <param name="AccessGroups">List of group ids that can access the resource.</param>
public record ResourceSecurity(List<string> AccessGroups);

/// <summary>Resources</summary>
/// <param name="Results">Results</param>
/// <param name="Facets">Facets</param>
/// <param name="Query">Query</param>
/// <param name="Total">Total</param>
/// <param name="PageNumber">PageNumber</param>
/// <param name="PageSize">PageSize</param>
/// <param name="NextPage">NextPage</param>
/// <param name="MinScore">Minimum bm25 score used to filter bm25 index search. Results with a lower score have been ignored.</param>
public record Resources(List<ResourceResult> Results, object? Facets, string? Query, int Total, int PageNumber, int PageSize, bool NextPage, float MinScore);

/// <summary>Row</summary>
/// <param name="Cell">Cell</param>
public record Row(List<string>? Cell);

/// <summary>RowsPreview</summary>
/// <param name="Sheets">Sheets</param>
public record RowsPreview(object? Sheets);

/// <summary>SearchRequest</summary>
/// <param name="AuditMetadata">A dictionary containing optional audit-specific metadata, such as user_id, environment, or other contextual information. This metadata can be leveraged for filtering and analyzing activity logs in future operations. Each key-value pair represents a piece of metadata relevant to the user's request.</param>
/// <param name="Query">The query to search for</param>
/// <param name="FilterExpression">Returns only documents that match this filter expression.Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters This allows building complex filtering expressions and replaces the following parameters:`fields`, `filters`, `range_*`, `resource_filters`, `keyword_filters`.</param>
/// <param name="Fields">The list of fields to search in. For instance: `a/title` to search only on title field. For more details on filtering by field, see: https://docs.nuclia.dev/docs/rag/advanced/search/#search-in-a-specific-field.</param>
/// <param name="Filters">The list of filters to apply. Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters</param>
/// <param name="TopK">The number of results search should return. The maximum number of results allowed is 200.</param>
/// <param name="MinScore">Minimum score to filter search results. Results with a lower score will be ignored. Accepts either a float or a dictionary with the minimum scores for the bm25 and vector indexes. If a float is provided, it is interpreted as the minimum score for vector index search.</param>
/// <param name="RangeCreationStart">Resources created before this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</param>
/// <param name="RangeCreationEnd">Resources created after this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</param>
/// <param name="RangeModificationStart">Resources modified before this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</param>
/// <param name="RangeModificationEnd">Resources modified after this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</param>
/// <param name="Debug">If set, the response will include some extra metadata for debugging purposes, like the list of queried nodes.</param>
/// <param name="Highlight">If set to true, the query terms will be highlighted in the results between <mark>...</mark> tags</param>
/// <param name="Show">Controls which types of metadata are serialized on resources of search results</param>
/// <param name="FieldTypeFilter">Define which field types are serialized on resources of search results</param>
/// <param name="Extracted">[Deprecated] Please use GET resource endpoint instead to get extracted metadata</param>
/// <param name="Vector">The vector to perform the search with. If not provided, NucliaDB will use Nuclia Predict API to create the vector off from the query.</param>
/// <param name="Vectorset">Vectors index to perform the search in. If not provided, NucliaDB will use the default one</param>
/// <param name="WithDuplicates">Whether to return duplicate paragraphs on the same document</param>
/// <param name="WithSynonyms">Whether to return matches for custom knowledge box synonyms of the query terms. Note: only supported for `keyword` and `fulltext` search options.</param>
/// <param name="Autofilter">If set to true, the search will automatically add filters to the query. For example, it will filter results containing the entities detected in the query</param>
/// <param name="ResourceFilters">List of resource ids to filter search results for. Only paragraphs from the specified resources will be returned.</param>
/// <param name="Security">Security metadata for the request. If not provided, the search request is done without the security lookup phase.</param>
/// <param name="ShowHidden">If set to false (default), excludes hidden resources from search</param>
/// <param name="Rephrase">Rephrase the query for a more efficient retrieval. This will consume LLM tokens and make the request slower.</param>
/// <param name="RephrasePrompt">Rephrase prompt given to the generative model responsible for rephrasing the query for a more effective retrieval step. This is only used if the `rephrase` flag is set to true in the request. If not specified, Nuclia's default prompt is used. It must include the {question} placeholder. The placeholder will be replaced with the original question</param>
/// <param name="QueryImage">Image that will be used together with the query text for retrieval.</param>
/// <param name="Features">List of search features to use. Each value corresponds to a lookup into on of the different indexes</param>
/// <param name="Faceted">The list of facets to calculate. The facets follow the same syntax as filters: https://docs.nuclia.dev/docs/rag/advanced/search-filters</param>
/// <param name="Sort">Options for results sorting</param>
public record SearchRequest(object? AuditMetadata, string Query, FilterExpression? FilterExpression, List<string> Fields, List<string>? Filters, int TopK, float? MinScore, string? RangeCreationStart, string? RangeCreationEnd, string? RangeModificationStart, string? RangeModificationEnd, bool Debug, bool Highlight, List<string> Show, List<string> FieldTypeFilter, List<string> Extracted, List<double>? Vector, string? Vectorset, bool WithDuplicates, bool WithSynonyms, bool Autofilter, List<string> ResourceFilters, RequestSecurity? Security, bool ShowHidden, bool Rephrase, string? RephrasePrompt, Image? QueryImage, List<string> Features, List<string> Faceted, SortOptions? Sort);

/// <summary>Sentences</summary>
/// <param name="Results">Results</param>
/// <param name="Facets">Facets</param>
/// <param name="PageNumber">PageNumber</param>
/// <param name="PageSize">PageSize</param>
/// <param name="MinScore">Minimum similarity score used to filter vector index search. Results with a lower score have been ignored.</param>
public record Sentences(List<NucliadbModelsSearchSentence> Results, object Facets, int PageNumber, int PageSize, float MinScore);

/// <summary>Sheet</summary>
/// <param name="Rows">Rows</param>
public record Sheet(List<Row>? Rows);

/// <summary>SortOptions</summary>
/// <param name="Field">Field</param>
/// <param name="Limit">Limit</param>
/// <param name="Order">Order</param>
public record SortOptions(string Field, int? Limit, string Order);

/// <summary>SourceNode</summary>
/// <param name="Prop">Prop</param>
/// <param name="Value">Value</param>
/// <param name="Match">Match</param>
/// <param name="Type">Type</param>
/// <param name="Group">Group</param>
public record SourceNode(string Prop, string? Value, string Match, string? Type, string? Group);

/// <summary>Model for the request payload of the summarize endpoint</summary>
/// <param name="GenerativeModel">The generative model to use for the summarization. If not provided, the model configured for the Knowledge Box is used.</param>
/// <param name="UserPrompt">Optional custom prompt input by the user</param>
/// <param name="Resources">Uids or slugs of the resources to summarize. If the resources are not found, they will be ignored.</param>
/// <param name="SummaryKind">SummaryKind</param>
public record SummarizeRequest(string? GenerativeModel, string? UserPrompt, List<string> Resources, string SummaryKind);

/// <summary>SummarizedResource</summary>
/// <param name="Summary">Summary of the resource</param>
/// <param name="Tokens">Tokens</param>
public record SummarizedResource(string Summary, int Tokens);

/// <summary>SummarizedResponse</summary>
/// <param name="Resources">Individual resource summaries. The key is the resource id or slug.</param>
/// <param name="Summary">Global summary of all resources combined.</param>
/// <param name="Consumption">Consumption</param>
public record SummarizedResponse(object Resources, string Summary, Consumption? Consumption);

/// <summary>SyncAskMetadata</summary>
/// <param name="Tokens">Number of tokens used in the LLM context and answer</param>
/// <param name="Timings">Timings of the generative model</param>
public record SyncAskMetadata(AskTokens? Tokens, AskTimings? Timings);

/// <summary>SyncAskResponse</summary>
/// <param name="Answer">The generative answer to the query</param>
/// <param name="Reasoning">The reasoning steps followed by the LLM to generate the answer. This is returned only if the reasoning feature is enabled in the request.</param>
/// <param name="AnswerJson">The generative JSON answer to the query. This is returned only if the answer_json_schema parameter is provided in the request.</param>
/// <param name="Status">The status of the query execution. It can be 'success', 'error', 'no_context' or 'no_retrieval_data'</param>
/// <param name="RetrievalResults">RetrievalResults</param>
/// <param name="RetrievalBestMatches">Sorted list of best matching text blocks in the retrieval step. This includes the main query and prequeries results, if any.</param>
/// <param name="Prequeries">The retrieval results of the prequeries</param>
/// <param name="LearningId">The id of the learning request. This id can be used to provide feedback on the learning process.</param>
/// <param name="Relations">The detected relations of the answer</param>
/// <param name="Citations">The citations of the answer. List of references to the resources used to generate the answer.</param>
/// <param name="AugmentedContext">Augmented text blocks that were sent to the LLM as part of the RAG strategies applied on the retrieval results in the request.</param>
/// <param name="PromptContext">The prompt context used to generate the answer. Returned only if the debug flag is set to true</param>
/// <param name="PredictRequest">The internal predict request used to generate the answer. Returned only if the debug flag is set to true</param>
/// <param name="Metadata">Metadata of the query execution. This includes the number of tokens used in the LLM context and answer, and the timings of the generative model.</param>
/// <param name="Consumption">The consumption of the query execution. Return only if 'X-show-consumption' header is set to true in the request.</param>
/// <param name="ErrorDetails">Error details message in case there was an error</param>
/// <param name="Debug">Debug information about the ask operation. The metadata included in this field is subject to change and should not be used in production. Note that it is only available if the `debug` parameter is set to true in the request.</param>
public record SyncAskResponse(string Answer, string? Reasoning, object? AnswerJson, string Status, KnowledgeboxFindResults RetrievalResults, List<AskRetrievalMatch> RetrievalBestMatches, object? Prequeries, string LearningId, Relations? Relations, object Citations, AugmentedContext? AugmentedContext, List<string>? PromptContext, object? PredictRequest, SyncAskMetadata? Metadata, Consumption? Consumption, string? ErrorDetails, object? Debug);

/// <summary>TableImageStrategy</summary>
/// <param name="Name">Name</param>
public record TableImageStrategy(string Name);

/// <summary>TextFieldData</summary>
/// <param name="Value">Value</param>
/// <param name="Extracted">Extracted</param>
/// <param name="Error">Error</param>
/// <param name="Status">Status</param>
/// <param name="Errors">Errors</param>
public record TextFieldData(FieldText? Value, TextFieldExtractedData? Extracted, Error? Error, string? Status, List<Error>? Errors);

/// <summary>TextFieldExtractedData</summary>
/// <param name="Text">Text</param>
/// <param name="Metadata">Metadata</param>
/// <param name="LargeMetadata">LargeMetadata</param>
/// <param name="Vectors">Vectors</param>
/// <param name="QuestionAnswers">QuestionAnswers</param>
public record TextFieldExtractedData(ExtractedText? Text, FieldComputedMetadata? Metadata, LargeComputedMetadata? LargeMetadata, VectorObject? Vectors, FieldQuestionAnswers? QuestionAnswers);

/// <summary>TextPosition</summary>
/// <param name="PageNumber">PageNumber</param>
/// <param name="Index">Index</param>
/// <param name="Start">Start</param>
/// <param name="End">End</param>
/// <param name="StartSeconds">StartSeconds</param>
/// <param name="EndSeconds">EndSeconds</param>
public record TextPosition(int? PageNumber, int Index, int Start, int End, List<int>? StartSeconds, List<int>? EndSeconds);

/// <summary>TokensDetail</summary>
/// <param name="Input">Input</param>
/// <param name="Output">Output</param>
/// <param name="Image">Image</param>
public record TokensDetail(float Input, float Output, float Image);

/// <summary>UserClassification</summary>
/// <param name="Labelset">Labelset</param>
/// <param name="Label">Label</param>
/// <param name="CancelledByUser">CancelledByUser</param>
public record UserClassification(string Labelset, string Label, bool CancelledByUser);

/// <summary>Field-level metadata set by the user via the rest api</summary>
/// <param name="Paragraphs">Paragraphs</param>
/// <param name="QuestionAnswers">QuestionAnswers</param>
/// <param name="Field">Field</param>
public record UserFieldMetadata(List<ParagraphAnnotation> Paragraphs, List<QuestionAnswerAnnotation> QuestionAnswers, FieldID Field);

/// <summary>UserMetadata</summary>
/// <param name="Classifications">Classifications</param>
/// <param name="Relations">Relations</param>
public record UserMetadata(List<UserClassification> Classifications, List<NucliadbModelsMetadataRelation> Relations);

/// <summary>Vector</summary>
/// <param name="Start">Start</param>
/// <param name="End">End</param>
/// <param name="StartParagraph">StartParagraph</param>
/// <param name="EndParagraph">EndParagraph</param>
/// <param name="VectorValue">VectorValue</param>
public record Vector(int? Start, int? End, int? StartParagraph, int? EndParagraph, List<double>? VectorValue);

/// <summary>VectorObject</summary>
/// <param name="Vectors">Vectors</param>
/// <param name="SplitVectors">SplitVectors</param>
/// <param name="DeletedSplits">DeletedSplits</param>
public record VectorObject(Vectors? Vectors, object? SplitVectors, List<string>? DeletedSplits);

/// <summary>Vectors</summary>
/// <param name="VectorsValue">VectorsValue</param>
public record Vectors(List<Vector>? VectorsValue);

/// <summary>NucliadbModelsCommonParagraph</summary>
/// <param name="Start">Start</param>
/// <param name="End">End</param>
/// <param name="StartSeconds">StartSeconds</param>
/// <param name="EndSeconds">EndSeconds</param>
/// <param name="Kind">Kind</param>
/// <param name="Classifications">Classifications</param>
/// <param name="Sentences">Sentences</param>
/// <param name="Key">Key</param>
/// <param name="Page">Page</param>
/// <param name="Representation">Representation</param>
/// <param name="Relations">Relations</param>
public record NucliadbModelsCommonParagraph(int? Start, int? End, List<int>? StartSeconds, List<int>? EndSeconds, string? Kind, List<Classification>? Classifications, List<NucliadbModelsCommonSentence>? Sentences, string? Key, PageInformation? Page, Representation? Representation, ParagraphRelations? Relations);

/// <summary>NucliadbModelsCommonSentence</summary>
/// <param name="Start">Start</param>
/// <param name="End">End</param>
/// <param name="Key">Key</param>
public record NucliadbModelsCommonSentence(int? Start, int? End, string? Key);

/// <summary>Matches if the field was generated by the given source</summary>
/// <param name="Prop">Prop</param>
/// <param name="By">Generator for this field. Currently, only data-augmentation is supported</param>
/// <param name="DaTask">Matches field generated by an specific DA task, given its prefix</param>
public record NucliadbModelsFiltersGenerated(string Prop, string By, string? DaTask);

/// <summary>Matches if the relation was generated by the given source</summary>
/// <param name="Prop">Prop</param>
/// <param name="By">By</param>
/// <param name="DaTask">Matches relations generated by an specific DA task, given its prefix</param>
public record NucliadbModelsGraphRequestsGenerated(string Prop, string By, string? DaTask);

/// <summary>NucliadbModelsSearchParagraph</summary>
/// <param name="Score">Score</param>
/// <param name="Rid">Rid</param>
/// <param name="FieldType">FieldType</param>
/// <param name="Field">Field</param>
/// <param name="Text">Text</param>
/// <param name="Labels">Labels</param>
/// <param name="StartSeconds">StartSeconds</param>
/// <param name="EndSeconds">EndSeconds</param>
/// <param name="Position">Position</param>
/// <param name="FuzzyResult">FuzzyResult</param>
public record NucliadbModelsSearchParagraph(float Score, string Rid, string FieldType, string Field, string Text, List<string> Labels, List<int>? StartSeconds, List<int>? EndSeconds, TextPosition? Position, bool FuzzyResult);

/// <summary>NucliadbModelsSearchSentence</summary>
/// <param name="Score">Score</param>
/// <param name="Rid">Rid</param>
/// <param name="Text">Text</param>
/// <param name="FieldType">FieldType</param>
/// <param name="Field">Field</param>
/// <param name="Index">Index</param>
/// <param name="Position">Position</param>
public record NucliadbModelsSearchSentence(float Score, string Rid, string Text, string FieldType, string Field, string? Index, TextPosition? Position);

/// <summary>AITables</summary>
/// <param name="Llm">Llm</param>
public record AITables(LLMConfig? Llm);

/// <summary>AnthropicKey</summary>
/// <param name="Key">Key</param>
public record AnthropicKey(string Key);

/// <summary>AskConfig</summary>
/// <param name="AuditMetadata">A dictionary containing optional audit-specific metadata, such as user_id, environment, or other contextual information. This metadata can be leveraged for filtering and analyzing activity logs in future operations. Each key-value pair represents a piece of metadata relevant to the user's request.</param>
/// <param name="TopK">The top most relevant results to fetch at the retrieval step. The maximum number of results allowed is 200.</param>
/// <param name="FilterExpression">Returns only documents that match this filter expression.Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters This allows building complex filtering expressions and replaces the following parameters:`fields`, `filters`, `range_*`, `resource_filters`, `keyword_filters`.</param>
/// <param name="Fields">The list of fields to search in. For instance: `a/title` to search only on title field. For more details on filtering by field, see: https://docs.nuclia.dev/docs/rag/advanced/search/#search-in-a-specific-field.</param>
/// <param name="Filters">The list of filters to apply. Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters</param>
/// <param name="KeywordFilters">List of keyword filter expressions to apply to the retrieval step. The text block search will only be performed on the documents that contain the specified keywords. The filters are case-insensitive, and only alphanumeric characters and spaces are allowed. Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters</param>
/// <param name="Vectorset">Vectors index to perform the search in. If not provided, NucliaDB will use the default one</param>
/// <param name="MinScore">Minimum score to filter search results. Results with a lower score will be ignored. Accepts either a float or a dictionary with the minimum scores for the bm25 and vector indexes. If a float is provided, it is interpreted as the minimum score for vector index search.</param>
/// <param name="Features">Features enabled for the chat endpoint. Semantic search is done if `semantic` is included. If `keyword` is included, the results will include matching paragraphs from the bm25 index. If `relations` is included, a graph of entities related to the answer is returned. `paragraphs` and `vectors` are deprecated, please use `keyword` and `semantic` instead</param>
/// <param name="RangeCreationStart">Resources created before this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</param>
/// <param name="RangeCreationEnd">Resources created after this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</param>
/// <param name="RangeModificationStart">Resources modified before this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</param>
/// <param name="RangeModificationEnd">Resources modified after this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</param>
/// <param name="Show">Controls which types of metadata are serialized on resources of search results</param>
/// <param name="FieldTypeFilter">Define which field types are serialized on resources of search results</param>
/// <param name="Extracted">[Deprecated] Please use GET resource endpoint instead to get extracted metadata</param>
/// <param name="Context">DEPRECATED! Please, use `chat_history` instead.</param>
/// <param name="ChatHistory">Use to rephrase the new LLM query by taking into account the chat conversation history. This will be passed to the LLM so that it is aware of the previous conversation.</param>
/// <param name="ExtraContext">Additional context that is added to the retrieval context sent to the LLM.         It allows extending the chat feature with content that may not be in the Knowledge Box.</param>
/// <param name="ExtraContextImages">Additional images added to the retrieval context sent to the LLM."         It allows extending the chat feature with content that may not be in the Knowledge Box.</param>
/// <param name="QueryImage">Image that will be used together with the query text for retrieval and then sent to the LLM as part of the context. If a query image is provided, the `extra_context_images` and `rag_images_strategies` will be disabled.</param>
/// <param name="Autofilter">If set to true, the search will automatically add filters to the query. For example, it will filter results containing the entities detected in the query</param>
/// <param name="Highlight">If set to true, the query terms will be highlighted in the results between <mark>...</mark> tags</param>
/// <param name="ResourceFilters">List of resource ids to filter search results for. Only paragraphs from the specified resources will be returned.</param>
/// <param name="Prompt">Use to customize the prompts given to the generative model. Both system and user prompts can be customized. If a string is provided, it is interpreted as the user prompt.</param>
/// <param name="RankFusion">Rank fusion algorithm to use to merge results from multiple retrievers (keyword, semantic)</param>
/// <param name="Reranker">Reranker let you specify which method you want to use to rerank your results at the end of retrieval</param>
/// <param name="Citations">Whether to include the citations for the answer in the response</param>
/// <param name="CitationThreshold">If citations is True, this sets the similarity threshold (0 to 1) for paragraphs to be included as citations. Lower values result in more citations. If not provided, Nuclia's default threshold is used.</param>
/// <param name="Security">Security metadata for the request. If not provided, the search request is done without the security lookup phase.</param>
/// <param name="ShowHidden">If set to false (default), excludes hidden resources from search</param>
/// <param name="RagStrategies">Options for tweaking how the context for the LLM model is crafted: - `full_resource` will add the full text of the matching resources to the context. This strategy cannot be combined with `hierarchy`, `neighbouring_paragraphs`, or `field_extension`. - `field_extension` will add the text of the matching resource's specified fields to the context. - `hierarchy` will add the title and summary text of the parent resource to the context for each matching paragraph. - `neighbouring_paragraphs` will add the sorrounding paragraphs to the context for each matching paragraph. - `metadata_extension` will add the metadata of the matching paragraphs or its resources to the context. - `prequeries` allows to run multiple retrieval queries before the main query and add the results to the context. The results of specific queries can be boosted by the specifying weights.  If empty, the default strategy is used, which simply adds the text of the matching paragraphs to the context.</param>
/// <param name="RagImagesStrategies">Options for tweaking how the image based context for the LLM model is crafted: - `page_image` will add the full page image of the matching resources to the context. - `tables` will send the table images for the paragraphs that contain tables and matched the retrieval query. - `paragraph_image` will add the images of the paragraphs that contain images (images for tables are not included). No image strategy is used by default. Note that this is only available for LLM models that support visual inputs. If the model does not support visual inputs, the image strategies will be ignored.</param>
/// <param name="Debug">If set, the response will include some extra metadata for debugging purposes, like the list of queried nodes.</param>
/// <param name="GenerativeModel">The generative model to use for the chat endpoint. If not provided, the model configured for the Knowledge Box is used.</param>
/// <param name="GenerativeModelSeed">The seed to use for the generative model for deterministic generation. Only supported by some models.</param>
/// <param name="MaxTokens">Use to limit the amount of tokens used in the LLM context and/or for generating the answer. If not provided, the default maximum tokens of the generative model will be used. If an integer is provided, it is interpreted as the maximum tokens for the answer.</param>
/// <param name="Rephrase">Rephrase the query for a more efficient retrieval. This will consume LLM tokens and make the request slower.</param>
/// <param name="ChatHistoryRelevanceThreshold">Threshold to determine if the past chat history is relevant to rephrase the user's question. 0 - Always treat previous messages as relevant (always rephrase).1 - Always treat previous messages as irrelevant (never rephrase).Values in between adjust the sensitivity.</param>
/// <param name="PreferMarkdown">If set to true, the response will be in markdown format</param>
/// <param name="AnswerJsonSchema">Desired JSON schema for the LLM answer. This schema is passed to the LLM so that it answers in a scructured format following the schema. If not provided, textual response is returned. Note that when using this parameter, the answer in the generative response will not be returned in chunks, the whole response text will be returned instead. Using this feature also disables the `citations` parameter. For maximal accuracy, please include a `description` for each field of the schema.</param>
/// <param name="GenerateAnswer">Whether to generate an answer using the generative model. If set to false, the response will only contain the retrieval results.</param>
/// <param name="Reasoning">Reasoning options for the generative model. Set to True to enable default reasoning, False to disable, or provide a Reasoning object for custom options.</param>
/// <param name="Query">Query</param>
public record AskConfig(object? AuditMetadata, int TopK, FilterExpression? FilterExpression, List<string> Fields, List<string>? Filters, List<string>? KeywordFilters, string? Vectorset, float? MinScore, List<string> Features, string? RangeCreationStart, string? RangeCreationEnd, string? RangeModificationStart, string? RangeModificationEnd, List<string> Show, List<string> FieldTypeFilter, List<string> Extracted, List<ChatContextMessage>? Context, List<ChatContextMessage>? ChatHistory, List<string>? ExtraContext, List<Image>? ExtraContextImages, Image? QueryImage, bool Autofilter, bool Highlight, List<string> ResourceFilters, string? Prompt, string? RankFusion, string? Reranker, bool Citations, float? CitationThreshold, RequestSecurity? Security, bool ShowHidden, List<object> RagStrategies, List<object> RagImagesStrategies, bool Debug, string? GenerativeModel, int? GenerativeModelSeed, int? MaxTokens, bool Rephrase, float? ChatHistoryRelevanceThreshold, bool PreferMarkdown, object? AnswerJsonSchema, bool GenerateAnswer, Reasoning? Reasoning, string? Query);

/// <summary>AskSearchConfiguration</summary>
/// <param name="Kind">Kind</param>
/// <param name="Config">Config</param>
public record AskSearchConfiguration(string Kind, AskConfig Config);

/// <summary>AzureMistralKey</summary>
/// <param name="Key">Key</param>
/// <param name="Url">Url</param>
public record AzureMistralKey(string Key, string Url);

/// <summary>AzureOpenAIKey</summary>
/// <param name="Key">Key</param>
/// <param name="Url">Url</param>
/// <param name="Deployment">Deployment</param>
/// <param name="Model">Model</param>
public record AzureOpenAIKey(string Key, string Url, string Deployment, string Model);

/// <summary>CreateEntitiesGroupPayload</summary>
/// <param name="Group">Group</param>
/// <param name="Entities">Entities</param>
/// <param name="Title">Title</param>
/// <param name="Color">Color</param>
public record CreateEntitiesGroupPayload(string Group, object Entities, string? Title, string? Color);

/// <summary>CreateExportResponse</summary>
/// <param name="ExportId">ExportId</param>
public record CreateExportResponse(string ExportId);

/// <summary>CreateImportResponse</summary>
/// <param name="ImportId">ImportId</param>
public record CreateImportResponse(string ImportId);

/// <summary>CreateResourcePayload</summary>
/// <param name="Title">Title</param>
/// <param name="Summary">Summary</param>
/// <param name="Slug">The slug is the user-defined id for the resource</param>
/// <param name="Icon">The icon should be a media type string: https://www.iana.org/assignments/media-types/media-types.xhtml</param>
/// <param name="Thumbnail">Thumbnail</param>
/// <param name="Metadata">Generic metadata for the resource. It can be used to store structured information about the resource that later is serialized on retrieval results, however this metadata can not be used for searching or filtering.</param>
/// <param name="Usermetadata">Usermetadata</param>
/// <param name="Fieldmetadata">Fieldmetadata</param>
/// <param name="Origin">Origin metadata for the resource. Used to store information about the resource on the origin system. Most of its fields can later be used to filter at search time.</param>
/// <param name="Extra">Extra metadata for the resource. It can be used to store structured information about the resource that can't be used to query at retrieval time.</param>
/// <param name="Hidden">Set the hidden status of the resource. If not set, the default value for new resources in the KnowledgeBox will be used.</param>
/// <param name="Files">Dictionary of file fields to be added to the resource. The keys correspond to the field id, and must comply with the regex: ^[a-zA-Z0-9:_-]+$</param>
/// <param name="Links">Dictionary of link fields to be added to the resource. The keys correspond to the field id, and must comply with the regex: ^[a-zA-Z0-9:_-]+$</param>
/// <param name="Texts">Dictionary of text fields to be added to the resource. The keys correspond to the field id, and must comply with the regex: ^[a-zA-Z0-9:_-]+$</param>
/// <param name="Conversations">Dictionary of conversation fields to be added to the resource. The keys correspond to the field id, and must comply with the regex: ^[a-zA-Z0-9:_-]+$</param>
/// <param name="ProcessingOptions">Options for processing the resource. If not set, the default options will be used.</param>
/// <param name="Security">Security metadata for the resource. It can be used to have fine-grained control over who can access the resource.</param>
public record CreateResourcePayload(string? Title, string? Summary, string? Slug, string? Icon, string? Thumbnail, InputMetadata? Metadata, UserMetadata? Usermetadata, List<UserFieldMetadata>? Fieldmetadata, InputOrigin? Origin, Extra? Extra, bool? Hidden, object Files, object Links, object Texts, object Conversations, PushProcessingOptions? ProcessingOptions, ResourceSecurity? Security);

/// <summary>CustomSplitStrategy</summary>

public record CustomSplitStrategy();

/// <summary>ExtractConfig</summary>
/// <param name="Name">Name</param>
/// <param name="VllmConfig">VllmConfig</param>
/// <param name="AiTables">AiTables</param>
/// <param name="Split">Split</param>
public record ExtractConfig(string Name, VLLMExtractionConfig? VllmConfig, AITables? AiTables, SplitConfig? Split);

/// <summary>FieldRef</summary>
/// <param name="FieldType">FieldType</param>
/// <param name="FieldId">FieldId</param>
/// <param name="Split">Split</param>
public record FieldRef(string FieldType, string FieldId, string? Split);

/// <summary>File</summary>
/// <param name="Filename">Filename</param>
/// <param name="ContentType">ContentType</param>
/// <param name="Payload">Base64 encoded file content</param>
/// <param name="Md5">Md5</param>
/// <param name="Uri">Uri</param>
/// <param name="ExtraHeaders">ExtraHeaders</param>
public record File(string? Filename, string ContentType, string? Payload, string? Md5, string? Uri, object ExtraHeaders);

/// <summary>FileB64</summary>
/// <param name="Filename">Filename</param>
/// <param name="ContentType">ContentType</param>
/// <param name="Payload">Payload</param>
/// <param name="Md5">Md5</param>
public record FileB64(string Filename, string ContentType, string Payload, string Md5);

/// <summary>FileField</summary>
/// <param name="Language">Language</param>
/// <param name="Password">Password</param>
/// <param name="File">File</param>
/// <param name="ExtractStrategy">Id of the Nuclia extract strategy to use at processing time. If not set, the default strategy will be used. Extract strategies are defined at the learning configuration api.</param>
/// <param name="SplitStrategy">Id of the Nuclia split strategy used at processing time. If not set, the default strategy was used. Split strategies are defined at the learning configuration api.</param>
public record FileField(string? Language, string? Password, File File, string? ExtractStrategy, string? SplitStrategy);

/// <summary>FindConfig</summary>
/// <param name="AuditMetadata">A dictionary containing optional audit-specific metadata, such as user_id, environment, or other contextual information. This metadata can be leveraged for filtering and analyzing activity logs in future operations. Each key-value pair represents a piece of metadata relevant to the user's request.</param>
/// <param name="Query">The query to search for</param>
/// <param name="FilterExpression">Returns only documents that match this filter expression.Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters This allows building complex filtering expressions and replaces the following parameters:`fields`, `filters`, `range_*`, `resource_filters`, `keyword_filters`.</param>
/// <param name="Fields">The list of fields to search in. For instance: `a/title` to search only on title field. For more details on filtering by field, see: https://docs.nuclia.dev/docs/rag/advanced/search/#search-in-a-specific-field.</param>
/// <param name="Filters">The list of filters to apply. Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters</param>
/// <param name="TopK">The number of results search should return. The maximum number of results allowed is 200.</param>
/// <param name="MinScore">Minimum score to filter search results. Results with a lower score will be ignored. Accepts either a float or a dictionary with the minimum scores for the bm25 and vector indexes. If a float is provided, it is interpreted as the minimum score for vector index search.</param>
/// <param name="RangeCreationStart">Resources created before this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</param>
/// <param name="RangeCreationEnd">Resources created after this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</param>
/// <param name="RangeModificationStart">Resources modified before this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</param>
/// <param name="RangeModificationEnd">Resources modified after this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</param>
/// <param name="Debug">If set, the response will include some extra metadata for debugging purposes, like the list of queried nodes.</param>
/// <param name="Highlight">If set to true, the query terms will be highlighted in the results between <mark>...</mark> tags</param>
/// <param name="Show">Controls which types of metadata are serialized on resources of search results</param>
/// <param name="FieldTypeFilter">Define which field types are serialized on resources of search results</param>
/// <param name="Extracted">[Deprecated] Please use GET resource endpoint instead to get extracted metadata</param>
/// <param name="Vector">The vector to perform the search with. If not provided, NucliaDB will use Nuclia Predict API to create the vector off from the query.</param>
/// <param name="Vectorset">Vectors index to perform the search in. If not provided, NucliaDB will use the default one</param>
/// <param name="WithDuplicates">Whether to return duplicate paragraphs on the same document</param>
/// <param name="WithSynonyms">Whether to return matches for custom knowledge box synonyms of the query terms. Note: only supported for `keyword` and `fulltext` search options.</param>
/// <param name="Autofilter">If set to true, the search will automatically add filters to the query. For example, it will filter results containing the entities detected in the query</param>
/// <param name="ResourceFilters">List of resource ids to filter search results for. Only paragraphs from the specified resources will be returned.</param>
/// <param name="Security">Security metadata for the request. If not provided, the search request is done without the security lookup phase.</param>
/// <param name="ShowHidden">If set to false (default), excludes hidden resources from search</param>
/// <param name="Rephrase">Rephrase the query for a more efficient retrieval. This will consume LLM tokens and make the request slower.</param>
/// <param name="RephrasePrompt">Rephrase prompt given to the generative model responsible for rephrasing the query for a more effective retrieval step. This is only used if the `rephrase` flag is set to true in the request. If not specified, Nuclia's default prompt is used. It must include the {question} placeholder. The placeholder will be replaced with the original question</param>
/// <param name="QueryImage">Image that will be used together with the query text for retrieval.</param>
/// <param name="GraphQuery">Query for the knowledge graph. Paths (node-relation-node) extracted from a paragraph_id will be used to extend the results</param>
/// <param name="Features">List of search features to use. Each value corresponds to a lookup into on of the different indexes</param>
/// <param name="RankFusion">Rank fusion algorithm to use to merge results from multiple retrievers (keyword, semantic)</param>
/// <param name="Reranker">Reranker let you specify which method you want to use to rerank your results at the end of retrieval</param>
/// <param name="KeywordFilters">List of keyword filter expressions to apply to the retrieval step. The text block search will only be performed on the documents that contain the specified keywords. The filters are case-insensitive, and only alphanumeric characters and spaces are allowed. Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters</param>
/// <param name="GenerativeModel">The generative model used to rephrase the query. If not provided, the model configured for the Knowledge Box is used.</param>
public record FindConfig(object? AuditMetadata, string Query, FilterExpression? FilterExpression, List<string> Fields, List<string>? Filters, int TopK, float? MinScore, string? RangeCreationStart, string? RangeCreationEnd, string? RangeModificationStart, string? RangeModificationEnd, bool Debug, bool Highlight, List<string> Show, List<string> FieldTypeFilter, List<string> Extracted, List<double>? Vector, string? Vectorset, bool WithDuplicates, bool WithSynonyms, bool Autofilter, List<string> ResourceFilters, RequestSecurity? Security, bool ShowHidden, bool Rephrase, string? RephrasePrompt, Image? QueryImage, object? GraphQuery, List<string> Features, string? RankFusion, string? Reranker, List<string>? KeywordFilters, string? GenerativeModel);

/// <summary>FindSearchConfiguration</summary>
/// <param name="Kind">Kind</param>
/// <param name="Config">Config</param>
public record FindSearchConfiguration(string Kind, FindConfig Config);

/// <summary>GraphNode</summary>
/// <param name="Value">Value</param>
/// <param name="Match">Match</param>
/// <param name="Type">Type</param>
/// <param name="Group">Group</param>
public record GraphNode(string? Value, string Match, string? Type, string? Group);

/// <summary>GraphPath</summary>
/// <param name="Prop">Prop</param>
/// <param name="Source">Source</param>
/// <param name="Relation">Relation</param>
/// <param name="Destination">Destination</param>
/// <param name="Undirected">Undirected</param>
public record GraphPath(string Prop, GraphNode? Source, GraphRelation? Relation, GraphNode? Destination, bool Undirected);

/// <summary>GraphRelation</summary>
/// <param name="Label">Label</param>
/// <param name="Type">Type</param>
public record GraphRelation(string? Label, string? Type);

/// <summary>Some models require a specific template (including prefix) to work correctly in each task For example Snowflake's Arctic-embed requires a specific prefix to work correctly. In that case, the query prompt will be ``` passage_prompt: "" query_prompt: "Represent this sentence for searching relevant passages: {}" ```` where {} will be replaced by the actual sentence. `passage_prompt` is empty because the model does not require alterations to the sentence to embed is as a passage.</summary>
/// <param name="Url">Url</param>
/// <param name="Key">Key</param>
/// <param name="Matryoshka">Matryoshka</param>
/// <param name="Similarity">Similarity</param>
/// <param name="Size">Size</param>
/// <param name="Threshold">Threshold</param>
/// <param name="PassagePrompt">PassagePrompt</param>
/// <param name="QueryPrompt">QueryPrompt</param>
public record HFEmbeddingKey(string Url, string Key, List<int> Matryoshka, string Similarity, int Size, float Threshold, string PassagePrompt, string QueryPrompt);

/// <summary>HFLLMKey</summary>
/// <param name="Key">Key</param>
/// <param name="Url">Url</param>
/// <param name="Model">Model</param>
public record HFLLMKey(string Key, string Url, ModelType Model);

/// <summary>InputConversationField</summary>
/// <param name="Messages">List of messages in the conversation field. Each message must have a unique ident.</param>
/// <param name="ExtractStrategy">Id of the Nuclia extract strategy used at processing time. If not set, the default strategy was used. Extract strategies are defined at the learning configuration api.</param>
/// <param name="SplitStrategy">Id of the Nuclia split strategy used at processing time. If not set, the default strategy was used. Split strategies are defined at the learning configuration api.</param>
public record InputConversationField(List<InputMessage> Messages, string? ExtractStrategy, string? SplitStrategy);

/// <summary>InputMessage</summary>
/// <param name="Timestamp">Time at which the message was sent, in ISO 8601 format.</param>
/// <param name="Who">Sender of the message, e.g. 'user' or 'assistant'</param>
/// <param name="To">List of recipients of the message, e.g. ['assistant'] or ['user']</param>
/// <param name="Content">Content</param>
/// <param name="Ident">Unique identifier for the message. Must be unique within the conversation.</param>
/// <param name="Type">Type</param>
public record InputMessage(string? Timestamp, string? Who, List<string> To, InputMessageContent Content, string Ident, string? Type);

/// <summary>InputMessageContent</summary>
/// <param name="Text">Text</param>
/// <param name="Format">Format</param>
/// <param name="Attachments">Attachments</param>
/// <param name="AttachmentsFields">AttachmentsFields</param>
public record InputMessageContent(string Text, string Format, List<FileB64> Attachments, List<FieldRef> AttachmentsFields);

/// <summary>InputMetadata</summary>
/// <param name="Metadata">Metadata</param>
/// <param name="Language">Language</param>
/// <param name="Languages">Languages</param>
public record InputMetadata(object Metadata, string? Language, List<string>? Languages);

/// <summary>InputOrigin</summary>
/// <param name="SourceId">SourceId</param>
/// <param name="Url">Url</param>
/// <param name="Created">Creation date of the resource at the origin system. This can be later used for date range filtering on search endpoints. Have a look at the advanced search documentation page: https://docs.nuclia.dev/docs/rag/advanced/search/#date-filtering</param>
/// <param name="Modified">Modification date of the resource at the origin system. This can be later used for date range filtering on search endpoints.  Have a look at the advanced search documentation page: https://docs.nuclia.dev/docs/rag/advanced/search/#date-filtering</param>
/// <param name="Metadata">Generic metadata from the resource at the origin system. It can later be used for filtering on search endpoints with '/origin.metadata/{key}/{value}'</param>
/// <param name="Tags">Resource tags about the origin system. It can later be used for filtering on search endpoints with '/origin.tags/{tag}'</param>
/// <param name="Collaborators">Collaborators</param>
/// <param name="Filename">Filename</param>
/// <param name="Related">Related</param>
/// <param name="Path">Path of the original resource. Typically used to store folder structure information of the resource at the origin system. It can be later used for filtering on search endpoints with '/origin.path/{path}'</param>
public record InputOrigin(string? SourceId, string? Url, string? Created, string? Modified, object Metadata, List<string> Tags, List<string> Collaborators, string? Filename, List<string> Related, string? Path);

/// <summary>KnowledgeBoxConfigInput</summary>
/// <param name="Slug">Slug for the Knowledge Box.</param>
/// <param name="Title">Title for the Knowledge Box.</param>
/// <param name="Description">Description for the Knowledge Box.</param>
/// <param name="LearningConfiguration">Learning configuration for the Knowledge Box. If provided, NucliaDB will set the learning configuration for the Knowledge Box.</param>
/// <param name="ExternalIndexProvider">External index provider for the Knowledge Box.</param>
/// <param name="ConfiguredExternalIndexProvider">Metadata for the configured external index provider (if any)</param>
/// <param name="Similarity">This field is deprecated. Use 'learning_configuration' instead.</param>
/// <param name="HiddenResourcesEnabled">Allow hiding resources</param>
/// <param name="HiddenResourcesHideOnCreation">Hide newly created resources</param>
public record KnowledgeBoxConfigInput(string? Slug, string? Title, string? Description, object? LearningConfiguration, PineconeIndexProvider? ExternalIndexProvider, object? ConfiguredExternalIndexProvider, string? Similarity, bool HiddenResourcesEnabled, bool HiddenResourcesHideOnCreation);

/// <summary>KnowledgeBoxConfigOutput</summary>
/// <param name="Slug">Slug for the Knowledge Box.</param>
/// <param name="Title">Title for the Knowledge Box.</param>
/// <param name="Description">Description for the Knowledge Box.</param>
/// <param name="LearningConfiguration">Learning configuration for the Knowledge Box. If provided, NucliaDB will set the learning configuration for the Knowledge Box.</param>
/// <param name="ExternalIndexProvider">External index provider for the Knowledge Box.</param>
/// <param name="ConfiguredExternalIndexProvider">Metadata for the configured external index provider (if any)</param>
/// <param name="Similarity">This field is deprecated. Use 'learning_configuration' instead.</param>
/// <param name="HiddenResourcesEnabled">Allow hiding resources</param>
/// <param name="HiddenResourcesHideOnCreation">Hide newly created resources</param>
public record KnowledgeBoxConfigOutput(string? Slug, string? Title, string? Description, object? LearningConfiguration, PineconeIndexProvider? ExternalIndexProvider, object? ConfiguredExternalIndexProvider, string? Similarity, bool HiddenResourcesEnabled, bool HiddenResourcesHideOnCreation);

/// <summary>The API representation of a Knowledge Box object.</summary>
/// <param name="Slug">Slug</param>
/// <param name="Uuid">Uuid</param>
/// <param name="Config">Config</param>
/// <param name="Model">Model</param>
public record KnowledgeBoxObj(string? Slug, string Uuid, KnowledgeBoxConfig? Config, SemanticModelMetadata? Model);

/// <summary>KnowledgeBoxObjID</summary>
/// <param name="Uuid">Uuid</param>
public record KnowledgeBoxObjID(string Uuid);

/// <summary>KnowledgeBoxSynonyms</summary>
/// <param name="Synonyms">Synonyms</param>
public record KnowledgeBoxSynonyms(object Synonyms);

/// <summary>LLMConfig</summary>
/// <param name="UserKeys">UserKeys</param>
/// <param name="GenerativeModel">GenerativeModel</param>
/// <param name="GenerativeProvider">GenerativeProvider</param>
/// <param name="GenerativePromptId">GenerativePromptId</param>
public record LLMConfig(UserLearningKeys? UserKeys, string GenerativeModel, string GenerativeProvider, string GenerativePromptId);

/// <summary>LLMSplitConfig</summary>
/// <param name="Rules">Rules</param>
/// <param name="Llm">Llm</param>
public record LLMSplitConfig(List<string> Rules, LLMConfig? Llm);

/// <summary>LabelSet</summary>
/// <param name="Title">Title</param>
/// <param name="Color">Color</param>
/// <param name="Multiple">Multiple</param>
/// <param name="Kind">Kind</param>
/// <param name="Labels">Labels</param>
public record LabelSet(string? Title, string? Color, bool Multiple, List<string> Kind, List<NucliadbModelsLabelsLabel> Labels);

/// <summary>LinkField</summary>
/// <param name="Headers">Headers</param>
/// <param name="Cookies">Cookies</param>
/// <param name="Uri">Uri</param>
/// <param name="Language">Language</param>
/// <param name="Localstorage">Localstorage</param>
/// <param name="CssSelector">CssSelector</param>
/// <param name="Xpath">Xpath</param>
/// <param name="ExtractStrategy">Id of the Nuclia extract strategy to use at processing time. If not set, the default strategy will be used. Extract strategies are defined at the learning configuration api.</param>
/// <param name="SplitStrategy">Id of the Nuclia split strategy used at processing time. If not set, the default strategy was used. Split strategies are defined at the learning configuration api.</param>
public record LinkField(object? Headers, object? Cookies, string Uri, string? Language, object? Localstorage, string? CssSelector, string? Xpath, string? ExtractStrategy, string? SplitStrategy);

/// <summary>ManualSplitConfig</summary>
/// <param name="Splitter">Splitter</param>
public record ManualSplitConfig(string Splitter);

/// <summary>MistralKey</summary>
/// <param name="Key">Key</param>
public record MistralKey(string Key);

/// <summary>ModelType</summary>

public record ModelType();

/// <summary>NewImportedKbResponse</summary>
/// <param name="Kbid">Kbid</param>
/// <param name="Slug">Slug</param>
public record NewImportedKbResponse(string Kbid, string Slug);

/// <summary>OpenAIKey</summary>
/// <param name="Key">Key</param>
/// <param name="Org">Org</param>
public record OpenAIKey(string Key, string Org);

/// <summary>PalmKey</summary>
/// <param name="Credentials">Credentials</param>
/// <param name="Location">Location</param>
public record PalmKey(string Credentials, string Location);

/// <summary>PineconeIndexProvider</summary>
/// <param name="Type">Type</param>
/// <param name="ApiKey">ApiKey</param>
/// <param name="ServerlessCloud">ServerlessCloud</param>
public record PineconeIndexProvider(string Type, string ApiKey, string ServerlessCloud);

/// <summary>PushProcessingOptions</summary>
/// <param name="MlText">MlText</param>
public record PushProcessingOptions(bool? MlText);

/// <summary>Matches all fields of a resource given its id or slug</summary>
/// <param name="Prop">Prop</param>
/// <param name="Id">UUID of the resource to match</param>
/// <param name="Slug">Slug of the resource to match</param>
public record Resource(string Prop, string? Id, string? Slug);

/// <summary>ResourceCreated</summary>
/// <param name="Uuid">Uuid</param>
/// <param name="Elapsed">Elapsed</param>
/// <param name="Seqid">Seqid</param>
public record ResourceCreated(string Uuid, float? Elapsed, int? Seqid);

/// <summary>ResourceFieldAdded</summary>
/// <param name="Seqid">Seqid</param>
public record ResourceFieldAdded(int? Seqid);

/// <summary>ResourceFileUploaded</summary>
/// <param name="Seqid">Seqid</param>
/// <param name="Uuid">Uuid</param>
/// <param name="FieldId">FieldId</param>
public record ResourceFileUploaded(int? Seqid, string? Uuid, string? FieldId);

/// <summary>ResourceUpdated</summary>
/// <param name="Seqid">Seqid</param>
public record ResourceUpdated(int? Seqid);

/// <summary>Metadata of the semantic model associated to the KB</summary>
/// <param name="SimilarityFunction">SimilarityFunction</param>
/// <param name="VectorDimension">Dimension of the indexed vectors/embeddings</param>
/// <param name="DefaultMinScore">Deprecated</param>
public record SemanticModelMetadata(string SimilarityFunction, int? VectorDimension, float? DefaultMinScore);

/// <summary>SplitConfig</summary>
/// <param name="MaxParagraph">MaxParagraph</param>
public record SplitConfig(int MaxParagraph);

/// <summary>Hey, developer! Keep this in sync with corresponding pydantic model in learning_config.models</summary>
/// <param name="Name">Name</param>
/// <param name="MaxParagraph">MaxParagraph</param>
/// <param name="CustomSplit">CustomSplit</param>
/// <param name="LlmSplit">LlmSplit</param>
/// <param name="ManualSplit">ManualSplit</param>
public record SplitConfiguration(string Name, int MaxParagraph, CustomSplitStrategy? CustomSplit, LLMSplitConfig? LlmSplit, ManualSplitConfig? ManualSplit);

/// <summary>TextField</summary>
/// <param name="Body">The text body. The format of the text should be specified in the format field. The sum of all text fields in the request may not exceed 2MB. If you need to store more text, consider using a file field instead or splitting into multiple requests for each text field.</param>
/// <param name="Format">Format</param>
/// <param name="ExtractStrategy">Id of the Nuclia extract strategy to use at processing time. If not set, the default strategy will be used. Extract strategies are defined at the learning configuration api.</param>
/// <param name="SplitStrategy">Id of the Nuclia split strategy used at processing time. If not set, the default strategy was used. Split strategies are defined at the learning configuration api.</param>
public record TextField(string Body, string Format, string? ExtractStrategy, string? SplitStrategy);

/// <summary>TextGenerationKey</summary>
/// <param name="Model">Model</param>
public record TextGenerationKey(string Model);

/// <summary>UpdateEntitiesGroupPayload</summary>
/// <param name="Title">Title</param>
/// <param name="Color">Color</param>
/// <param name="Add">Add</param>
/// <param name="Update">Update</param>
/// <param name="Delete">Delete</param>
public record UpdateEntitiesGroupPayload(string? Title, string? Color, object Add, object Update, List<string> Delete);

/// <summary>UpdateResourcePayload</summary>
/// <param name="Title">Title</param>
/// <param name="Summary">Summary</param>
/// <param name="Slug">The slug is the user-defined id for the resource</param>
/// <param name="Thumbnail">Thumbnail</param>
/// <param name="Metadata">Metadata</param>
/// <param name="Usermetadata">Usermetadata</param>
/// <param name="Fieldmetadata">Fieldmetadata</param>
/// <param name="Origin">Origin</param>
/// <param name="Extra">Extra metadata for the resource. It can be used to store structured information about the resource that can't be used to query at retrieval time. If not set, the existing extra metadata will not be modified.</param>
/// <param name="Files">Dictionary of file fields to be added to the resource. The keys correspond to the field id, and must comply with the regex: ^[a-zA-Z0-9:_-]+$</param>
/// <param name="Links">Dictionary of link fields to be added to the resource. The keys correspond to the field id, and must comply with the regex: ^[a-zA-Z0-9:_-]+$</param>
/// <param name="Texts">Dictionary of text fields to be added to the resource. The keys correspond to the field id, and must comply with the regex: ^[a-zA-Z0-9:_-]+$</param>
/// <param name="Conversations">Dictionary of conversation fields to be added to the resource. The keys correspond to the field id, and must comply with the regex: ^[a-zA-Z0-9:_-]+$</param>
/// <param name="ProcessingOptions">Options for processing the resource. If not set, the default options will be used.</param>
/// <param name="Security">Security metadata for the resource. It can be used to have fine-grained control over who can access the resource.</param>
/// <param name="Hidden">Modify the hidden status of the resource. If not set, the hidden status will not be modified.</param>
public record UpdateResourcePayload(string? Title, string? Summary, string? Slug, string? Thumbnail, InputMetadata? Metadata, UserMetadata? Usermetadata, List<UserFieldMetadata>? Fieldmetadata, InputOrigin? Origin, Extra? Extra, object Files, object Links, object Texts, object Conversations, PushProcessingOptions? ProcessingOptions, ResourceSecurity? Security, bool? Hidden);

/// <summary>UserLearningKeys</summary>
/// <param name="Openai">Openai</param>
/// <param name="AzureOpenai">AzureOpenai</param>
/// <param name="Palm">Palm</param>
/// <param name="Anthropic">Anthropic</param>
/// <param name="Claude3">Claude3</param>
/// <param name="TextGeneration">TextGeneration</param>
/// <param name="Mistral">Mistral</param>
/// <param name="AzureMistral">AzureMistral</param>
/// <param name="HfLlm">HfLlm</param>
/// <param name="HfEmbedding">HfEmbedding</param>
public record UserLearningKeys(OpenAIKey? Openai, AzureOpenAIKey? AzureOpenai, PalmKey? Palm, AnthropicKey? Anthropic, AnthropicKey? Claude3, TextGenerationKey? TextGeneration, MistralKey? Mistral, AzureMistralKey? AzureMistral, HFLLMKey? HfLlm, HFEmbeddingKey? HfEmbedding);

/// <summary>VLLMExtractionConfig</summary>
/// <param name="Rules">Rules</param>
/// <param name="Llm">Llm</param>
public record VLLMExtractionConfig(List<string> Rules, LLMConfig? Llm);

/// <summary>NucliadbModelsEntitiesEntity</summary>
/// <param name="Value">Value</param>
/// <param name="Merged">Merged</param>
/// <param name="Represents">Represents</param>
public record NucliadbModelsEntitiesEntity(string Value, bool Merged, List<string> Represents);

/// <summary>Matches fields that contains a detected entity</summary>
/// <param name="Prop">Prop</param>
/// <param name="Subtype">Type of the entity. e.g: PERSON</param>
/// <param name="Value">Value of the entity. e.g: Anna. If blank, matches any entity of the given type</param>
public record NucliadbModelsFiltersEntity(string Prop, string Subtype, string? Value);

/// <summary>Matches fields/paragraphs with a label (or labelset)</summary>
/// <param name="Prop">Prop</param>
/// <param name="Labelset">The labelset to match</param>
/// <param name="Label">The label to match. If blank, matches all labels in the given labelset</param>
public record NucliadbModelsFiltersLabel(string Prop, string Labelset, string? Label);

/// <summary>NucliadbModelsGraphRequestsRelation</summary>
/// <param name="Prop">Prop</param>
/// <param name="Label">Label</param>
/// <param name="Type">Type</param>
public record NucliadbModelsGraphRequestsRelation(string Prop, string? Label, string? Type);

/// <summary>NucliadbModelsLabelsLabel</summary>
/// <param name="Title">Title</param>
/// <param name="Related">Related</param>
/// <param name="Text">Text</param>
/// <param name="Uri">Uri</param>
public record NucliadbModelsLabelsLabel(string Title, string? Related, string? Text, string? Uri);

/// <summary>NucliadbModelsMetadataRelation</summary>
/// <param name="Relation">Relation</param>
/// <param name="Label">Label</param>
/// <param name="Metadata">Metadata</param>
/// <param name="From">From</param>
/// <param name="To">To</param>
public record NucliadbModelsMetadataRelation(string Relation, string? Label, RelationMetadata? Metadata, RelationEntity? From, RelationEntity To);

/// <summary>EntitiesGroup</summary>
/// <param name="Title">Title of the entities group</param>
/// <param name="Color">Color of the entities group. This is for display purposes only.</param>
/// <param name="Custom">Denotes if it has been created by the user</param>
/// <param name="Entities">Entities</param>
public record EntitiesGroup(string? Title, string? Color, bool Custom, object Entities);

/// <summary>EntitiesGroupSummary</summary>
/// <param name="Title">Title of the entities group</param>
/// <param name="Color">Color of the entities group. This is for display purposes only.</param>
/// <param name="Custom">Denotes if it has been created by the user</param>
/// <param name="Entities">This field is deprecated and will be removed in future versions. It will always be empty. Use the /api/v1/kb/{kbid}/entitiesgroup/{group} endpoint to get the entities of a group.</param>
public record EntitiesGroupSummary(string? Title, string? Color, bool Custom, object Entities);

/// <summary>KnowledgeBoxConfig</summary>
/// <param name="Slug">Slug for the Knowledge Box.</param>
/// <param name="Title">Title for the Knowledge Box.</param>
/// <param name="Description">Description for the Knowledge Box.</param>
/// <param name="LearningConfiguration">Learning configuration for the Knowledge Box. If provided, NucliaDB will set the learning configuration for the Knowledge Box.</param>
/// <param name="ExternalIndexProvider">External index provider for the Knowledge Box.</param>
/// <param name="ConfiguredExternalIndexProvider">Metadata for the configured external index provider (if any)</param>
/// <param name="Similarity">This field is deprecated. Use 'learning_configuration' instead.</param>
/// <param name="HiddenResourcesEnabled">Allow hiding resources</param>
/// <param name="HiddenResourcesHideOnCreation">Hide newly created resources</param>
public record KnowledgeBoxConfig(string? Slug, string? Title, string? Description, object? LearningConfiguration, PineconeIndexProvider? ExternalIndexProvider, object? ConfiguredExternalIndexProvider, string? Similarity, bool HiddenResourcesEnabled, bool HiddenResourcesHideOnCreation);

/// <summary>KnowledgeBoxEntities</summary>
/// <param name="Uuid">Uuid</param>
/// <param name="Groups">Groups</param>
public record KnowledgeBoxEntities(string Uuid, object Groups);

/// <summary>KnowledgeBoxLabels</summary>
/// <param name="Uuid">Uuid</param>
/// <param name="Labelsets">Labelsets</param>
public record KnowledgeBoxLabels(string Uuid, object Labelsets);

/// <summary>Paragraph</summary>
/// <param name="Start">Start</param>
/// <param name="End">End</param>
/// <param name="StartSeconds">StartSeconds</param>
/// <param name="EndSeconds">EndSeconds</param>
/// <param name="Kind">Kind</param>
/// <param name="Classifications">Classifications</param>
/// <param name="Sentences">Sentences</param>
/// <param name="Key">Key</param>
/// <param name="Page">Page</param>
/// <param name="Representation">Representation</param>
/// <param name="Relations">Relations</param>
public record Paragraph(int? Start, int? End, List<int>? StartSeconds, List<int>? EndSeconds, string? Kind, List<Classification>? Classifications, List<Sentence>? Sentences, string? Key, PageInformation? Page, Representation? Representation, ParagraphRelations? Relations);

/// <summary>RequestsResult</summary>
/// <param name="ProcessingId">Processing ID of the resource.</param>
/// <param name="ResourceId">Resource ID.</param>
/// <param name="Kbid">Kbid</param>
/// <param name="Title">Title of the resource.</param>
/// <param name="Labels">Labels of the resource.</param>
/// <param name="Completed">Whether the resource has been completed</param>
/// <param name="Scheduled">Whether the resource has been scheduled</param>
/// <param name="Timestamp">Timestamp of when the resource was first scheduled.</param>
/// <param name="CompletedAt">Timestamp of when the resource was completed</param>
/// <param name="ScheduledAt">Timestamp of when the resource was first scheduled.</param>
/// <param name="Failed">Whether the resource has failed to process</param>
/// <param name="Retries">Number of retries for the resource.</param>
/// <param name="ScheduleEta">Estimated time until the resource is scheduled.</param>
/// <param name="ScheduleOrder">Order of the resource in the schedule queue.</param>
public record RequestsResult(string ProcessingId, string ResourceId, string Kbid, string? Title, List<string> Labels, bool Completed, bool Scheduled, string Timestamp, string? CompletedAt, string? ScheduledAt, bool Failed, int Retries, float ScheduleEta, int ScheduleOrder);

/// <summary>RequestsResults</summary>
/// <param name="Results">List of results.</param>
/// <param name="Cursor">Cursor to use for the next page of results.</param>
public record RequestsResults(List<RequestsResult> Results, string? Cursor);

/// <summary>ResourceField</summary>
/// <param name="FieldType">FieldType</param>
/// <param name="FieldId">FieldId</param>
/// <param name="Value">Value</param>
/// <param name="Extracted">Extracted</param>
/// <param name="Error">Error</param>
/// <param name="Status">Status</param>
/// <param name="Errors">Errors</param>
public record ResourceField(string FieldType, string FieldId, object Value, TextFieldExtractedData? Extracted, Error? Error, string? Status, List<Error>? Errors);

/// <summary>ResourceList</summary>
/// <param name="Resources">Resources</param>
/// <param name="Pagination">Pagination</param>
public record ResourceList(List<NucliadbModelsResourceResource> Resources, ResourcePagination Pagination);

/// <summary>ResourcePagination</summary>
/// <param name="Page">Page</param>
/// <param name="Size">Size</param>
/// <param name="Last">Last</param>
public record ResourcePagination(int Page, int Size, bool Last);

/// <summary>Sentence</summary>
/// <param name="Start">Start</param>
/// <param name="End">End</param>
/// <param name="Key">Key</param>
public record Sentence(int? Start, int? End, string? Key);

/// <summary>StatusResponse</summary>
/// <param name="Status">Status</param>
/// <param name="Total">Total</param>
/// <param name="Processed">Processed</param>
/// <param name="Retries">Retries</param>
public record StatusResponse(string Status, int Total, int Processed, int Retries);

/// <summary>NucliadbModelsExtractedEntity</summary>
/// <param name="Token">Token</param>
/// <param name="Root">Root</param>
/// <param name="Type">Type</param>
public record NucliadbModelsExtractedEntity(string? Token, string? Root, string? Type);

/// <summary>Matches all fields of a resource given its id or slug</summary>
/// <param name="Prop">Prop</param>
/// <param name="Id">UUID of the resource to match</param>
/// <param name="Slug">Slug of the resource to match</param>
public record NucliadbModelsFiltersResource(string Prop, string? Id, string? Slug);

/// <summary>NucliadbModelsResourceResource</summary>
/// <param name="Id">Id</param>
/// <param name="Slug">Slug</param>
/// <param name="Title">Title</param>
/// <param name="Summary">Summary</param>
/// <param name="Icon">Icon</param>
/// <param name="Thumbnail">Thumbnail</param>
/// <param name="Metadata">Metadata</param>
/// <param name="Usermetadata">Usermetadata</param>
/// <param name="Fieldmetadata">Fieldmetadata</param>
/// <param name="Computedmetadata">Computedmetadata</param>
/// <param name="Created">Created</param>
/// <param name="Modified">Modified</param>
/// <param name="LastSeqid">LastSeqid</param>
/// <param name="LastAccountSeq">LastAccountSeq</param>
/// <param name="Queue">Queue</param>
/// <param name="Hidden">Hidden</param>
/// <param name="Origin">Origin</param>
/// <param name="Extra">Extra</param>
/// <param name="Relations">Relations</param>
/// <param name="Data">Data</param>
/// <param name="Security">Resource security metadata</param>
public record NucliadbModelsResourceResource(string Id, string? Slug, string? Title, string? Summary, string? Icon, string? Thumbnail, Metadata? Metadata, UserMetadata? Usermetadata, List<UserFieldMetadata>? Fieldmetadata, ComputedMetadata? Computedmetadata, string? Created, string? Modified, int? LastSeqid, int? LastAccountSeq, string? Queue, bool? Hidden, Origin? Origin, Extra? Extra, List<NucliadbModelsMetadataRelation>? Relations, ResourceData? Data, ResourceSecurity? Security);