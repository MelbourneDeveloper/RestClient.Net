namespace NucliaDB.Generated;

/// <summary>An enumeration.</summary>
public class AnonimizationModel
{

}

/// <summary>An enumeration.</summary>
public class GenerativeModel
{

}

/// <summary>HTTPValidationError</summary>
public class HTTPValidationError
{
    /// <summary>Detail</summary>
    public List<ValidationError> Detail { get; set; }
}

/// <summary>LearningConfigurationUpdate</summary>
public class LearningConfigurationUpdate
{
    /// <summary>AnonymizationModel</summary>
    public object AnonymizationModel { get; set; }

    /// <summary>GenerativeModel</summary>
    public object GenerativeModel { get; set; }

    /// <summary>NerModel</summary>
    public object NerModel { get; set; }
}

/// <summary>An enumeration.</summary>
public class NERModel
{

}

/// <summary>Model to map in a generic way what we really store on the db, without valdations. As enum values containing the versions change from time to time, and we don't keep historics, we cannot use the model enums here, as it will fail with older values</summary>
public class StoredLearningConfiguration
{
    /// <summary>SemanticModel</summary>
    public string SemanticModel { get; set; }

    /// <summary>AnonymizationModel</summary>
    public string AnonymizationModel { get; set; }

    /// <summary>GenerativeModel</summary>
    public string GenerativeModel { get; set; }

    /// <summary>NerModel</summary>
    public string NerModel { get; set; }

    /// <summary>SemanticVectorSimilarity</summary>
    public string SemanticVectorSimilarity { get; set; }

    /// <summary>SemanticVectorSize</summary>
    public int SemanticVectorSize { get; set; }
}

/// <summary>ValidationError</summary>
public class ValidationError
{
    /// <summary>Loc</summary>
    public List<object> Loc { get; set; }

    /// <summary>Msg</summary>
    public string Msg { get; set; }

    /// <summary>Type</summary>
    public string Type { get; set; }
}

/// <summary>AgentType</summary>
public class AgentType
{

}

/// <summary>AgentsFilter</summary>
public class AgentsFilter
{
    /// <summary>Type</summary>
    public AgentType Type { get; set; }

    /// <summary>list of task names. If None or empty, all tasks for that operation are applied.</summary>
    public List<string> TaskNames { get; set; }
}

/// <summary>AndFieldFilterExpression</summary>
public class AndFieldFilterExpression
{

}

/// <summary>AndGraphNodesQuery</summary>
public class AndGraphNodesQuery
{
    /// <summary>Operands</summary>
    public List<object> Operands { get; set; }
}

/// <summary>AndGraphPathQuery</summary>
public class AndGraphPathQuery
{

}

/// <summary>AndGraphRelationsQuery</summary>
public class AndGraphRelationsQuery
{
    /// <summary>Operands</summary>
    public List<object> Operands { get; set; }
}

/// <summary>AndParagraphFilterExpression</summary>
public class AndParagraphFilterExpression
{

}

/// <summary>AndResourceFilterExpression</summary>
public class AndResourceFilterExpression
{
    /// <summary>Operands</summary>
    public List<object> Operands { get; set; }
}

/// <summary>Answer</summary>
public class Answer
{
    /// <summary>Text</summary>
    public string Text { get; set; }

    /// <summary>Language</summary>
    public object Language { get; set; }

    /// <summary>IdsParagraphs</summary>
    public List<string> IdsParagraphs { get; set; }
}

/// <summary>AnyNode</summary>
public class AnyNode
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>Value</summary>
    public object Value { get; set; }

    /// <summary>Match</summary>
    public NodeMatchKindName Match { get; set; }

    /// <summary>Type</summary>
    public object Type { get; set; }

    /// <summary>Group</summary>
    public object Group { get; set; }
}

/// <summary>AppliedDataAugmentation</summary>
public class AppliedDataAugmentation
{
    /// <summary>Question and answers generated by the Question Answers agent</summary>
    public object Qas { get; set; }

    /// <summary>New text fields. Only generated by the Generator agent as of now.</summary>
    public List<NewTextField> NewTextFields { get; set; }

    /// <summary>Indicates if the FieldMetadata was changed by the agents</summary>
    public bool Changed { get; set; }
}

/// <summary>AskRequest</summary>
public class AskRequest
{
    /// <summary>A dictionary containing optional audit-specific metadata, such as user_id, environment, or other contextual information. This metadata can be leveraged for filtering and analyzing activity logs in future operations. Each key-value pair represents a piece of metadata relevant to the user's request.</summary>
    public object AuditMetadata { get; set; }

    /// <summary>The query to get a generative answer for</summary>
    public string Query { get; set; }

    /// <summary>The top most relevant results to fetch at the retrieval step. The maximum number of results allowed is 200.</summary>
    public int TopK { get; set; }

    /// <summary>Returns only documents that match this filter expression.Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters This allows building complex filtering expressions and replaces the following parameters:`fields`, `filters`, `range_*`, `resource_filters`, `keyword_filters`.</summary>
    public object FilterExpression { get; set; }

    /// <summary>The list of fields to search in. For instance: `a/title` to search only on title field. For more details on filtering by field, see: https://docs.nuclia.dev/docs/rag/advanced/search/#search-in-a-specific-field.</summary>
    public List<string> Fields { get; set; }

    /// <summary>The list of filters to apply. Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters</summary>
    public object Filters { get; set; }

    /// <summary>List of keyword filter expressions to apply to the retrieval step. The text block search will only be performed on the documents that contain the specified keywords. The filters are case-insensitive, and only alphanumeric characters and spaces are allowed. Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters</summary>
    public object KeywordFilters { get; set; }

    /// <summary>Vectors index to perform the search in. If not provided, NucliaDB will use the default one</summary>
    public object Vectorset { get; set; }

    /// <summary>Minimum score to filter search results. Results with a lower score will be ignored. Accepts either a float or a dictionary with the minimum scores for the bm25 and vector indexes. If a float is provided, it is interpreted as the minimum score for vector index search.</summary>
    public object MinScore { get; set; }

    /// <summary>Features enabled for the chat endpoint. Semantic search is done if `semantic` is included. If `keyword` is included, the results will include matching paragraphs from the bm25 index. If `relations` is included, a graph of entities related to the answer is returned. `paragraphs` and `vectors` are deprecated, please use `keyword` and `semantic` instead</summary>
    public List<ChatOptions> Features { get; set; }

    /// <summary>Resources created before this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</summary>
    public object RangeCreationStart { get; set; }

    /// <summary>Resources created after this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</summary>
    public object RangeCreationEnd { get; set; }

    /// <summary>Resources modified before this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</summary>
    public object RangeModificationStart { get; set; }

    /// <summary>Resources modified after this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</summary>
    public object RangeModificationEnd { get; set; }

    /// <summary>Controls which types of metadata are serialized on resources of search results</summary>
    public List<ResourceProperties> Show { get; set; }

    /// <summary>Define which field types are serialized on resources of search results</summary>
    public List<FieldTypeName> FieldTypeFilter { get; set; }

    /// <summary>[Deprecated] Please use GET resource endpoint instead to get extracted metadata</summary>
    public List<ExtractedDataTypeName> Extracted { get; set; }

    /// <summary>DEPRECATED! Please, use `chat_history` instead.</summary>
    public object Context { get; set; }

    /// <summary>Use to rephrase the new LLM query by taking into account the chat conversation history. This will be passed to the LLM so that it is aware of the previous conversation.</summary>
    public object ChatHistory { get; set; }

    /// <summary>Additional context that is added to the retrieval context sent to the LLM.         It allows extending the chat feature with content that may not be in the Knowledge Box.</summary>
    public object ExtraContext { get; set; }

    /// <summary>Additional images added to the retrieval context sent to the LLM."         It allows extending the chat feature with content that may not be in the Knowledge Box.</summary>
    public object ExtraContextImages { get; set; }

    /// <summary>Image that will be used together with the query text for retrieval and then sent to the LLM as part of the context. If a query image is provided, the `extra_context_images` and `rag_images_strategies` will be disabled.</summary>
    public object QueryImage { get; set; }

    /// <summary>If set to true, the search will automatically add filters to the query. For example, it will filter results containing the entities detected in the query</summary>
    public bool Autofilter { get; set; }

    /// <summary>If set to true, the query terms will be highlighted in the results between <mark>...</mark> tags</summary>
    public bool Highlight { get; set; }

    /// <summary>List of resource ids to filter search results for. Only paragraphs from the specified resources will be returned.</summary>
    public List<string> ResourceFilters { get; set; }

    /// <summary>Use to customize the prompts given to the generative model. Both system and user prompts can be customized. If a string is provided, it is interpreted as the user prompt.</summary>
    public object Prompt { get; set; }

    /// <summary>Rank fusion algorithm to use to merge results from multiple retrievers (keyword, semantic)</summary>
    public object RankFusion { get; set; }

    /// <summary>Reranker let you specify which method you want to use to rerank your results at the end of retrieval</summary>
    public object Reranker { get; set; }

    /// <summary>Whether to include the citations for the answer in the response</summary>
    public bool Citations { get; set; }

    /// <summary>If citations is True, this sets the similarity threshold (0 to 1) for paragraphs to be included as citations. Lower values result in more citations. If not provided, Nuclia's default threshold is used.</summary>
    public object CitationThreshold { get; set; }

    /// <summary>Security metadata for the request. If not provided, the search request is done without the security lookup phase.</summary>
    public object Security { get; set; }

    /// <summary>If set to false (default), excludes hidden resources from search</summary>
    public bool ShowHidden { get; set; }

    /// <summary>Options for tweaking how the context for the LLM model is crafted: - `full_resource` will add the full text of the matching resources to the context. This strategy cannot be combined with `hierarchy`, `neighbouring_paragraphs`, or `field_extension`. - `field_extension` will add the text of the matching resource's specified fields to the context. - `hierarchy` will add the title and summary text of the parent resource to the context for each matching paragraph. - `neighbouring_paragraphs` will add the sorrounding paragraphs to the context for each matching paragraph. - `metadata_extension` will add the metadata of the matching paragraphs or its resources to the context. - `prequeries` allows to run multiple retrieval queries before the main query and add the results to the context. The results of specific queries can be boosted by the specifying weights.  If empty, the default strategy is used, which simply adds the text of the matching paragraphs to the context.</summary>
    public List<object> RagStrategies { get; set; }

    /// <summary>Options for tweaking how the image based context for the LLM model is crafted: - `page_image` will add the full page image of the matching resources to the context. - `tables` will send the table images for the paragraphs that contain tables and matched the retrieval query. - `paragraph_image` will add the images of the paragraphs that contain images (images for tables are not included). No image strategy is used by default. Note that this is only available for LLM models that support visual inputs. If the model does not support visual inputs, the image strategies will be ignored.</summary>
    public List<object> RagImagesStrategies { get; set; }

    /// <summary>If set, the response will include some extra metadata for debugging purposes, like the list of queried nodes.</summary>
    public bool Debug { get; set; }

    /// <summary>The generative model to use for the chat endpoint. If not provided, the model configured for the Knowledge Box is used.</summary>
    public object GenerativeModel { get; set; }

    /// <summary>The seed to use for the generative model for deterministic generation. Only supported by some models.</summary>
    public object GenerativeModelSeed { get; set; }

    /// <summary>Use to limit the amount of tokens used in the LLM context and/or for generating the answer. If not provided, the default maximum tokens of the generative model will be used. If an integer is provided, it is interpreted as the maximum tokens for the answer.</summary>
    public object MaxTokens { get; set; }

    /// <summary>Rephrase the query for a more efficient retrieval. This will consume LLM tokens and make the request slower.</summary>
    public bool Rephrase { get; set; }

    /// <summary>Threshold to determine if the past chat history is relevant to rephrase the user's question. 0 - Always treat previous messages as relevant (always rephrase).1 - Always treat previous messages as irrelevant (never rephrase).Values in between adjust the sensitivity.</summary>
    public object ChatHistoryRelevanceThreshold { get; set; }

    /// <summary>If set to true, the response will be in markdown format</summary>
    public bool PreferMarkdown { get; set; }

    /// <summary>Desired JSON schema for the LLM answer. This schema is passed to the LLM so that it answers in a scructured format following the schema. If not provided, textual response is returned. Note that when using this parameter, the answer in the generative response will not be returned in chunks, the whole response text will be returned instead. Using this feature also disables the `citations` parameter. For maximal accuracy, please include a `description` for each field of the schema.</summary>
    public object AnswerJsonSchema { get; set; }

    /// <summary>Whether to generate an answer using the generative model. If set to false, the response will only contain the retrieval results.</summary>
    public bool GenerateAnswer { get; set; }

    /// <summary>Load ask parameters from this configuration. Parameters in the request override parameters from the configuration.</summary>
    public object SearchConfiguration { get; set; }

    /// <summary>Reasoning options for the generative model. Set to True to enable default reasoning, False to disable, or provide a Reasoning object for custom options.</summary>
    public object Reasoning { get; set; }
}

/// <summary>AskRetrievalMatch</summary>
public class AskRetrievalMatch
{
    /// <summary>Id of the matching text block</summary>
    public string Id { get; set; }
}

/// <summary>AskTimings</summary>
public class AskTimings
{
    /// <summary>Time the LLM took to generate the first chunk of the answer</summary>
    public object GenerativeFirstChunk { get; set; }

    /// <summary>Total time the LLM took to generate the answer</summary>
    public object GenerativeTotal { get; set; }
}

/// <summary>AskTokens</summary>
public class AskTokens
{
    /// <summary>Number of LLM tokens used for the context in the query</summary>
    public int Input { get; set; }

    /// <summary>Number of LLM tokens used for the answer</summary>
    public int Output { get; set; }

    /// <summary>Number of Nuclia LLM tokens used for the context in the query</summary>
    public object InputNuclia { get; set; }

    /// <summary>Number of Nuclia LLM tokens used for the answer</summary>
    public object OutputNuclia { get; set; }
}

/// <summary>AugmentedContext</summary>
public class AugmentedContext
{
    /// <summary>Paragraphs added to the context as a result of using the `rag_strategies` parameter, typically the neighbouring_paragraphs or the conversation strategies</summary>
    public object Paragraphs { get; set; }

    /// <summary>Field extracted texts added to the context as a result of using the `rag_strategies` parameter, typically the hierarcy or full_resource strategies.</summary>
    public object Fields { get; set; }
}

/// <summary>AugmentedField</summary>
public class AugmentedField
{
    /// <summary>Metadata</summary>
    public FieldMetadata Metadata { get; set; }

    /// <summary>AppliedDataAugmentation</summary>
    public AppliedDataAugmentation AppliedDataAugmentation { get; set; }

    /// <summary>InputNucliaTokens</summary>
    public float InputNucliaTokens { get; set; }

    /// <summary>OutputNucliaTokens</summary>
    public float OutputNucliaTokens { get; set; }

    /// <summary>Time</summary>
    public float Time { get; set; }
}

/// <summary>AugmentedTextBlock</summary>
public class AugmentedTextBlock
{
    /// <summary>The id of the augmented text bloc. It can be a paragraph id or a field id.</summary>
    public string Id { get; set; }

    /// <summary>The text of the augmented text block. It may include additional metadata to enrich the context</summary>
    public string Text { get; set; }

    /// <summary>Metadata about the position of the text block in the original document.</summary>
    public object Position { get; set; }

    /// <summary>The parent text block that was augmented for.</summary>
    public object Parent { get; set; }

    /// <summary>AugmentationType</summary>
    public TextBlockAugmentationType AugmentationType { get; set; }
}

/// <summary>Author</summary>
public class Author
{

}

/// <summary>Returns only documents that match this filter expression. Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters  This allows building complex filtering expressions and replaces the following parameters: `filters`, `range_*`, `with_status`.</summary>
public class CatalogFilterExpression
{
    /// <summary>Filter to apply to resources</summary>
    public object Resource { get; set; }
}

/// <summary>CatalogQuery</summary>
public class CatalogQuery
{
    /// <summary>Field</summary>
    public CatalogQueryField Field { get; set; }

    /// <summary>Match</summary>
    public CatalogQueryMatch Match { get; set; }

    /// <summary>Text to search for</summary>
    public string Query { get; set; }
}

/// <summary>CatalogQueryField</summary>
public class CatalogQueryField
{

}

/// <summary>CatalogQueryMatch</summary>
public class CatalogQueryMatch
{

}

/// <summary>CatalogRequest</summary>
public class CatalogRequest
{
    /// <summary>The query to search for</summary>
    public object Query { get; set; }

    /// <summary>Returns only documents that match this filter expression.Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters This allows building complex filtering expressions and replaces the following parameters:`filters`, `range_*`, `with_status`.</summary>
    public object FilterExpression { get; set; }

    /// <summary>The list of facets to calculate. The facets follow the same syntax as filters: https://docs.nuclia.dev/docs/rag/advanced/search-filters</summary>
    public List<string> Faceted { get; set; }

    /// <summary>Options for results sorting</summary>
    public object Sort { get; set; }

    /// <summary>The page number of the results to return</summary>
    public int PageNumber { get; set; }

    /// <summary>The number of results to return per page. The maximum number of results per page allowed is 200.</summary>
    public int PageSize { get; set; }

    /// <summary>Set to filter only hidden or only non-hidden resources. Default is to return everything</summary>
    public object Hidden { get; set; }

    /// <summary>Controls which types of metadata are serialized on resources of search results</summary>
    public List<ResourceProperties> Show { get; set; }

    /// <summary>The list of filters to apply. Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters</summary>
    public object Filters { get; set; }

    /// <summary>Filter results by resource processing status</summary>
    public object WithStatus { get; set; }

    /// <summary>Resources created before this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</summary>
    public object RangeCreationStart { get; set; }

    /// <summary>Resources created after this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</summary>
    public object RangeCreationEnd { get; set; }

    /// <summary>Resources modified before this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</summary>
    public object RangeModificationStart { get; set; }

    /// <summary>Resources modified after this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</summary>
    public object RangeModificationEnd { get; set; }
}

/// <summary>ChatContextMessage</summary>
public class ChatContextMessage
{
    /// <summary>Author</summary>
    public Author Author { get; set; }

    /// <summary>Text</summary>
    public string Text { get; set; }
}

/// <summary>ChatOptions</summary>
public class ChatOptions
{

}

/// <summary>Classification</summary>
public class Classification
{
    /// <summary>Labelset</summary>
    public string Labelset { get; set; }

    /// <summary>Label</summary>
    public string Label { get; set; }
}

/// <summary>CloudLink</summary>
public class CloudLink
{
    /// <summary>Uri</summary>
    public object Uri { get; set; }

    /// <summary>Size</summary>
    public object Size { get; set; }

    /// <summary>ContentType</summary>
    public object ContentType { get; set; }

    /// <summary>Filename</summary>
    public object Filename { get; set; }

    /// <summary>Md5</summary>
    public object Md5 { get; set; }
}

/// <summary>The purpose of this field is to show a cherry-picked set of fields from computed metadata without having to load the whole computed metadata field.</summary>
public class ComputedMetadata
{
    /// <summary>FieldClassifications</summary>
    public List<FieldClassification> FieldClassifications { get; set; }
}

/// <summary>Consumption</summary>
public class Consumption
{
    /// <summary>NormalizedTokens</summary>
    public TokensDetail NormalizedTokens { get; set; }

    /// <summary>CustomerKeyTokens</summary>
    public TokensDetail CustomerKeyTokens { get; set; }
}

/// <summary>ConversationFieldData</summary>
public class ConversationFieldData
{
    /// <summary>Value</summary>
    public object Value { get; set; }

    /// <summary>Extracted</summary>
    public object Extracted { get; set; }

    /// <summary>Error</summary>
    public object Error { get; set; }

    /// <summary>Status</summary>
    public object Status { get; set; }

    /// <summary>Errors</summary>
    public object Errors { get; set; }
}

/// <summary>ConversationFieldExtractedData</summary>
public class ConversationFieldExtractedData
{
    /// <summary>Text</summary>
    public object Text { get; set; }

    /// <summary>Metadata</summary>
    public object Metadata { get; set; }

    /// <summary>LargeMetadata</summary>
    public object LargeMetadata { get; set; }

    /// <summary>Vectors</summary>
    public object Vectors { get; set; }

    /// <summary>QuestionAnswers</summary>
    public object QuestionAnswers { get; set; }
}

/// <summary>ConversationalStrategy</summary>
public class ConversationalStrategy
{
    /// <summary>Name</summary>
    public string Name { get; set; }

    /// <summary>Add attachments on context retrieved on conversation</summary>
    public bool AttachmentsText { get; set; }

    /// <summary>Add attachments images on context retrieved on conversation if they are mime type image and using a visual LLM</summary>
    public bool AttachmentsImages { get; set; }

    /// <summary>Add all conversation fields on matched blocks</summary>
    public bool Full { get; set; }

    /// <summary>Max messages to append in case its not full field</summary>
    public int MaxMessages { get; set; }
}

/// <summary>CustomPrompt</summary>
public class CustomPrompt
{
    /// <summary>System prompt given to the generative model responsible of generating the answer. This can help customize the behavior of the model when generating the answer. If not specified, the default model provider's prompt is used.</summary>
    public object System { get; set; }

    /// <summary>User prompt given to the generative model responsible of generating the answer. Use the words {context} and {question} in brackets where you want those fields to be placed, in case you want them in your prompt. Context will be the data returned by the retrieval step and question will be the user's query.</summary>
    public object User { get; set; }

    /// <summary>Rephrase prompt given to the generative model responsible for rephrasing the query for a more effective retrieval step. This is only used if the `rephrase` flag is set to true in the request. If not specified, Nuclia's default prompt is used. It must include the {question} placeholder. The placeholder will be replaced with the original question</summary>
    public object Rephrase { get; set; }
}

/// <summary>Matches all fields created in a date range</summary>
public class DateCreated
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>Start of the date range. Leave blank for unbounded</summary>
    public object Since { get; set; }

    /// <summary>End of the date range. Leave blank for unbounded</summary>
    public object Until { get; set; }
}

/// <summary>Matches all fields modified in a date range</summary>
public class DateModified
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>Start of the date range. Leave blank for unbounded</summary>
    public object Since { get; set; }

    /// <summary>End of the date range. Leave blank for unbounded</summary>
    public object Until { get; set; }
}

/// <summary>DestinationNode</summary>
public class DestinationNode
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>Value</summary>
    public object Value { get; set; }

    /// <summary>Match</summary>
    public NodeMatchKindName Match { get; set; }

    /// <summary>Type</summary>
    public object Type { get; set; }

    /// <summary>Group</summary>
    public object Group { get; set; }
}

/// <summary>DirectionalRelation</summary>
public class DirectionalRelation
{
    /// <summary>Entity</summary>
    public string Entity { get; set; }

    /// <summary>EntityType</summary>
    public RelationNodeType EntityType { get; set; }

    /// <summary>EntitySubtype</summary>
    public string EntitySubtype { get; set; }

    /// <summary>Relation</summary>
    public RelationType Relation { get; set; }

    /// <summary>RelationLabel</summary>
    public string RelationLabel { get; set; }

    /// <summary>Direction</summary>
    public RelationDirection Direction { get; set; }

    /// <summary>Metadata</summary>
    public object Metadata { get; set; }

    /// <summary>ResourceId</summary>
    public string ResourceId { get; set; }
}

/// <summary>Matches fields that contains a detected entity</summary>
public class EntityInput
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>Type of the entity. e.g: PERSON</summary>
    public string Subtype { get; set; }

    /// <summary>Value of the entity. e.g: Anna. If blank, matches any entity of the given type</summary>
    public object Value { get; set; }
}

/// <summary>EntityOutput</summary>
public class EntityOutput
{
    /// <summary>Token</summary>
    public object Token { get; set; }

    /// <summary>Root</summary>
    public object Root { get; set; }

    /// <summary>Type</summary>
    public object Type { get; set; }
}

/// <summary>EntitySubgraph</summary>
public class EntitySubgraph
{
    /// <summary>RelatedTo</summary>
    public List<DirectionalRelation> RelatedTo { get; set; }
}

/// <summary>Error</summary>
public class Error
{
    /// <summary>Body</summary>
    public string Body { get; set; }

    /// <summary>Code</summary>
    public int Code { get; set; }

    /// <summary>CodeStr</summary>
    public string CodeStr { get; set; }

    /// <summary>Created</summary>
    public object Created { get; set; }

    /// <summary>Severity</summary>
    public string Severity { get; set; }
}

/// <summary>Extra</summary>
public class Extra
{
    /// <summary>Arbitrary JSON metadata provided by the user that is not meant to be searchable, but can be serialized on results.</summary>
    public object Metadata { get; set; }
}

/// <summary>ExtractedDataTypeName</summary>
public class ExtractedDataTypeName
{

}

/// <summary>ExtractedText</summary>
public class ExtractedText
{
    /// <summary>Text</summary>
    public object Text { get; set; }

    /// <summary>SplitText</summary>
    public object SplitText { get; set; }

    /// <summary>DeletedSplits</summary>
    public object DeletedSplits { get; set; }
}

/// <summary>FeedbackRequest</summary>
public class FeedbackRequest
{
    /// <summary>Id of the request to provide feedback for. This id is returned in the response header `Nuclia-Learning-Id` of the chat endpoint.</summary>
    public string Ident { get; set; }

    /// <summary>Whether the result was good or not</summary>
    public bool Good { get; set; }

    /// <summary>Task</summary>
    public FeedbackTasks Task { get; set; }

    /// <summary>Feedback text</summary>
    public object Feedback { get; set; }

    /// <summary>Text block id</summary>
    public object TextBlockId { get; set; }
}

/// <summary>FeedbackTasks</summary>
public class FeedbackTasks
{

}

/// <summary>Matches a field or set of fields</summary>
public class Field
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>Type</summary>
    public FieldTypeName Type { get; set; }

    /// <summary>Name of the field to match. If blank, matches all fields of the given type</summary>
    public object Name { get; set; }
}

/// <summary>FieldClassification</summary>
public class FieldClassification
{
    /// <summary>Field</summary>
    public FieldID Field { get; set; }

    /// <summary>Classifications</summary>
    public List<Classification> Classifications { get; set; }
}

/// <summary>FieldComputedMetadata</summary>
public class FieldComputedMetadata
{
    /// <summary>Metadata</summary>
    public FieldMetadata Metadata { get; set; }

    /// <summary>SplitMetadata</summary>
    public object SplitMetadata { get; set; }

    /// <summary>DeletedSplits</summary>
    public object DeletedSplits { get; set; }
}

/// <summary>This is a metadata representation of a conversation about how many pages of messages and total of messages we have.  This class is used mainly when exposing a conversation in the resource level</summary>
public class FieldConversation
{
    /// <summary>Pages</summary>
    public object Pages { get; set; }

    /// <summary>Size</summary>
    public object Size { get; set; }

    /// <summary>Total</summary>
    public object Total { get; set; }

    /// <summary>ExtractStrategy</summary>
    public object ExtractStrategy { get; set; }

    /// <summary>SplitStrategy</summary>
    public object SplitStrategy { get; set; }
}

/// <summary>Wrapper for the entities extracted from a field (required because protobuf doesn't support lists of lists)</summary>
public class FieldEntities
{
    /// <summary>Entities</summary>
    public List<FieldEntity> Entities { get; set; }
}

/// <summary>FieldEntity</summary>
public class FieldEntity
{
    /// <summary>Text</summary>
    public string Text { get; set; }

    /// <summary>Label</summary>
    public string Label { get; set; }

    /// <summary>Positions</summary>
    public List<Position> Positions { get; set; }
}

/// <summary>FieldExtensionStrategy</summary>
public class FieldExtensionStrategy
{
    /// <summary>Name</summary>
    public string Name { get; set; }

    /// <summary>List of field ids to extend the context with. It will try to extend the retrieval context with the specified fields in the matching resources. The field ids have to be in the format `{field_type}/{field_name}`, like 'a/title', 'a/summary' for title and summary fields or 't/amend' for a text field named 'amend'.</summary>
    public List<string> Fields { get; set; }
}

/// <summary>FieldFile</summary>
public class FieldFile
{
    /// <summary>Added</summary>
    public object Added { get; set; }

    /// <summary>File</summary>
    public object File { get; set; }

    /// <summary>Language</summary>
    public object Language { get; set; }

    /// <summary>Password</summary>
    public object Password { get; set; }

    /// <summary>External</summary>
    public bool External { get; set; }

    /// <summary>Id of the Nuclia extract strategy used at processing time. If not set, the default strategy was used. Extract strategies are defined at the learning configuration api.</summary>
    public object ExtractStrategy { get; set; }

    /// <summary>Id of the Nuclia split strategy used at processing time. If not set, the default strategy was used. Split strategies are defined at the learning configuration api.</summary>
    public object SplitStrategy { get; set; }
}

/// <summary>FieldID</summary>
public class FieldID
{
    /// <summary>FieldType</summary>
    public FieldType FieldType { get; set; }

    /// <summary>Field</summary>
    public string Field { get; set; }
}

/// <summary>FieldLargeMetadata</summary>
public class FieldLargeMetadata
{
    /// <summary>Entities</summary>
    public object Entities { get; set; }

    /// <summary>Tokens</summary>
    public object Tokens { get; set; }
}

/// <summary>FieldLink</summary>
public class FieldLink
{
    /// <summary>Added</summary>
    public object Added { get; set; }

    /// <summary>Headers</summary>
    public object Headers { get; set; }

    /// <summary>Cookies</summary>
    public object Cookies { get; set; }

    /// <summary>Uri</summary>
    public object Uri { get; set; }

    /// <summary>Language</summary>
    public object Language { get; set; }

    /// <summary>Localstorage</summary>
    public object Localstorage { get; set; }

    /// <summary>CssSelector</summary>
    public object CssSelector { get; set; }

    /// <summary>Xpath</summary>
    public object Xpath { get; set; }

    /// <summary>Id of the Nuclia extract strategy used at processing time. If not set, the default strategy was used. Extract strategies are defined at the learning configuration api.</summary>
    public object ExtractStrategy { get; set; }

    /// <summary>Id of the Nuclia split strategy used at processing time. If not set, the default strategy was used. Split strategies are defined at the learning configuration api.</summary>
    public object SplitStrategy { get; set; }
}

/// <summary>FieldMetadata</summary>
public class FieldMetadata
{
    /// <summary>Links</summary>
    public List<string> Links { get; set; }

    /// <summary>Paragraphs</summary>
    public List<Paragraph> Paragraphs { get; set; }

    /// <summary>Ner</summary>
    public object Ner { get; set; }

    /// <summary>Entities</summary>
    public object Entities { get; set; }

    /// <summary>Classifications</summary>
    public List<Classification> Classifications { get; set; }

    /// <summary>LastIndex</summary>
    public object LastIndex { get; set; }

    /// <summary>LastUnderstanding</summary>
    public object LastUnderstanding { get; set; }

    /// <summary>LastExtract</summary>
    public object LastExtract { get; set; }

    /// <summary>LastSummary</summary>
    public object LastSummary { get; set; }

    /// <summary>LastProcessingStart</summary>
    public object LastProcessingStart { get; set; }

    /// <summary>Thumbnail</summary>
    public object Thumbnail { get; set; }

    /// <summary>Language</summary>
    public object Language { get; set; }

    /// <summary>Summary</summary>
    public object Summary { get; set; }

    /// <summary>Positions</summary>
    public object Positions { get; set; }

    /// <summary>Relations</summary>
    public object Relations { get; set; }

    /// <summary>MimeType</summary>
    public object MimeType { get; set; }
}

/// <summary>Matches fields with a mimetype</summary>
public class FieldMimetype
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>Type of the mimetype to match. e.g: In image/jpeg, type is image</summary>
    public string Type { get; set; }

    /// <summary>Type of the mimetype to match. e.g: In image/jpeg, subtype is jpeg.Leave blank to match all mimetype of the type</summary>
    public object Subtype { get; set; }
}

/// <summary>FieldQuestionAnswers</summary>
public class FieldQuestionAnswers
{
    /// <summary>QuestionAnswers</summary>
    public QuestionAnswers QuestionAnswers { get; set; }

    /// <summary>SplitQuestionAnswers</summary>
    public object SplitQuestionAnswers { get; set; }

    /// <summary>DeletedSplits</summary>
    public object DeletedSplits { get; set; }
}

/// <summary>FieldText</summary>
public class FieldText
{
    /// <summary>Body</summary>
    public object Body { get; set; }

    /// <summary>Format</summary>
    public object Format { get; set; }

    /// <summary>Md5</summary>
    public object Md5 { get; set; }

    /// <summary>Id of the Nuclia extract strategy used at processing time. If not set, the default strategy was used. Extract strategies are defined at the learning configuration api.</summary>
    public object ExtractStrategy { get; set; }

    /// <summary>Id of the Nuclia split strategy used at processing time. If not set, the default strategy was used. Split strategies are defined at the learning configuration api.</summary>
    public object SplitStrategy { get; set; }
}

/// <summary>FieldType</summary>
public class FieldType
{

}

/// <summary>This map assumes that both values and extracted data field containers use the same names for its fields. See models.ResourceFieldValues and models.ResourceFieldExtractedData</summary>
public class FieldTypeName
{

}

/// <summary>FileExtractedData</summary>
public class FileExtractedData
{
    /// <summary>Language</summary>
    public object Language { get; set; }

    /// <summary>Md5</summary>
    public object Md5 { get; set; }

    /// <summary>Metadata</summary>
    public object Metadata { get; set; }

    /// <summary>Nested</summary>
    public object Nested { get; set; }

    /// <summary>FileGenerated</summary>
    public object FileGenerated { get; set; }

    /// <summary>FileRowsPreviews</summary>
    public object FileRowsPreviews { get; set; }

    /// <summary>FilePreview</summary>
    public object FilePreview { get; set; }

    /// <summary>FilePagesPreviews</summary>
    public object FilePagesPreviews { get; set; }

    /// <summary>FileThumbnail</summary>
    public object FileThumbnail { get; set; }

    /// <summary>Field</summary>
    public object Field { get; set; }

    /// <summary>Icon</summary>
    public object Icon { get; set; }

    /// <summary>NestedPosition</summary>
    public object NestedPosition { get; set; }

    /// <summary>NestedListPosition</summary>
    public object NestedListPosition { get; set; }
}

/// <summary>FileFieldData</summary>
public class FileFieldData
{
    /// <summary>Value</summary>
    public object Value { get; set; }

    /// <summary>Extracted</summary>
    public object Extracted { get; set; }

    /// <summary>Error</summary>
    public object Error { get; set; }

    /// <summary>Status</summary>
    public object Status { get; set; }

    /// <summary>Errors</summary>
    public object Errors { get; set; }
}

/// <summary>FileFieldExtractedData</summary>
public class FileFieldExtractedData
{
    /// <summary>Text</summary>
    public object Text { get; set; }

    /// <summary>Metadata</summary>
    public object Metadata { get; set; }

    /// <summary>LargeMetadata</summary>
    public object LargeMetadata { get; set; }

    /// <summary>Vectors</summary>
    public object Vectors { get; set; }

    /// <summary>QuestionAnswers</summary>
    public object QuestionAnswers { get; set; }

    /// <summary>File</summary>
    public object File { get; set; }
}

/// <summary>FilePages</summary>
public class FilePages
{
    /// <summary>Pages</summary>
    public object Pages { get; set; }

    /// <summary>Positions</summary>
    public object Positions { get; set; }

    /// <summary>Structures</summary>
    public object Structures { get; set; }
}

/// <summary>Filter</summary>
public class Filter
{
    /// <summary>All</summary>
    public object All { get; set; }

    /// <summary>Any</summary>
    public object Any { get; set; }

    /// <summary>None</summary>
    public object None { get; set; }

    /// <summary>NotAll</summary>
    public object NotAll { get; set; }
}

/// <summary>Returns only documents that match this filter expression. Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters  This allows building complex filtering expressions and replaces the following parameters: `fields`, `filters`, `range_*`, `resource_filters`, `keyword_filters`.</summary>
public class FilterExpression
{
    /// <summary>Filter to apply to fields</summary>
    public object Field { get; set; }

    /// <summary>Filter to apply to each text block</summary>
    public object Paragraph { get; set; }

    /// <summary>Operator</summary>
    public Operator Operator { get; set; }
}

/// <summary>FindField</summary>
public class FindField
{
    /// <summary>Paragraphs</summary>
    public object Paragraphs { get; set; }
}

/// <summary>FindOptions</summary>
public class FindOptions
{

}

/// <summary>FindParagraph</summary>
public class FindParagraph
{
    /// <summary>Score</summary>
    public float Score { get; set; }

    /// <summary>ScoreType</summary>
    public SCORETYPE ScoreType { get; set; }

    /// <summary>Order</summary>
    public int Order { get; set; }

    /// <summary>Text</summary>
    public string Text { get; set; }

    /// <summary>Id</summary>
    public string Id { get; set; }

    /// <summary>Labels</summary>
    public object Labels { get; set; }

    /// <summary>Position</summary>
    public object Position { get; set; }

    /// <summary>FuzzyResult</summary>
    public bool FuzzyResult { get; set; }

    /// <summary>This flag informs if the page may have information that has not been extracted</summary>
    public bool PageWithVisual { get; set; }

    /// <summary>Reference to the extracted image that represents this paragraph</summary>
    public object Reference { get; set; }

    /// <summary>The referenced image of the paragraph is a table</summary>
    public bool IsATable { get; set; }

    /// <summary>Relevant relations from which the paragraph was found, will only be filled if using the Graph RAG Strategy</summary>
    public object RelevantRelations { get; set; }
}

/// <summary>FindRequest</summary>
public class FindRequest
{
    /// <summary>A dictionary containing optional audit-specific metadata, such as user_id, environment, or other contextual information. This metadata can be leveraged for filtering and analyzing activity logs in future operations. Each key-value pair represents a piece of metadata relevant to the user's request.</summary>
    public object AuditMetadata { get; set; }

    /// <summary>The query to search for</summary>
    public string Query { get; set; }

    /// <summary>Returns only documents that match this filter expression.Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters This allows building complex filtering expressions and replaces the following parameters:`fields`, `filters`, `range_*`, `resource_filters`, `keyword_filters`.</summary>
    public object FilterExpression { get; set; }

    /// <summary>The list of fields to search in. For instance: `a/title` to search only on title field. For more details on filtering by field, see: https://docs.nuclia.dev/docs/rag/advanced/search/#search-in-a-specific-field.</summary>
    public List<string> Fields { get; set; }

    /// <summary>The list of filters to apply. Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters</summary>
    public object Filters { get; set; }

    /// <summary>The number of results search should return. The maximum number of results allowed is 200.</summary>
    public int TopK { get; set; }

    /// <summary>Minimum score to filter search results. Results with a lower score will be ignored. Accepts either a float or a dictionary with the minimum scores for the bm25 and vector indexes. If a float is provided, it is interpreted as the minimum score for vector index search.</summary>
    public object MinScore { get; set; }

    /// <summary>Resources created before this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</summary>
    public object RangeCreationStart { get; set; }

    /// <summary>Resources created after this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</summary>
    public object RangeCreationEnd { get; set; }

    /// <summary>Resources modified before this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</summary>
    public object RangeModificationStart { get; set; }

    /// <summary>Resources modified after this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</summary>
    public object RangeModificationEnd { get; set; }

    /// <summary>If set, the response will include some extra metadata for debugging purposes, like the list of queried nodes.</summary>
    public bool Debug { get; set; }

    /// <summary>If set to true, the query terms will be highlighted in the results between <mark>...</mark> tags</summary>
    public bool Highlight { get; set; }

    /// <summary>Controls which types of metadata are serialized on resources of search results</summary>
    public List<ResourceProperties> Show { get; set; }

    /// <summary>Define which field types are serialized on resources of search results</summary>
    public List<FieldTypeName> FieldTypeFilter { get; set; }

    /// <summary>[Deprecated] Please use GET resource endpoint instead to get extracted metadata</summary>
    public List<ExtractedDataTypeName> Extracted { get; set; }

    /// <summary>The vector to perform the search with. If not provided, NucliaDB will use Nuclia Predict API to create the vector off from the query.</summary>
    public object Vector { get; set; }

    /// <summary>Vectors index to perform the search in. If not provided, NucliaDB will use the default one</summary>
    public object Vectorset { get; set; }

    /// <summary>Whether to return duplicate paragraphs on the same document</summary>
    public bool WithDuplicates { get; set; }

    /// <summary>Whether to return matches for custom knowledge box synonyms of the query terms. Note: only supported for `keyword` and `fulltext` search options.</summary>
    public bool WithSynonyms { get; set; }

    /// <summary>If set to true, the search will automatically add filters to the query. For example, it will filter results containing the entities detected in the query</summary>
    public bool Autofilter { get; set; }

    /// <summary>List of resource ids to filter search results for. Only paragraphs from the specified resources will be returned.</summary>
    public List<string> ResourceFilters { get; set; }

    /// <summary>Security metadata for the request. If not provided, the search request is done without the security lookup phase.</summary>
    public object Security { get; set; }

    /// <summary>If set to false (default), excludes hidden resources from search</summary>
    public bool ShowHidden { get; set; }

    /// <summary>Rephrase the query for a more efficient retrieval. This will consume LLM tokens and make the request slower.</summary>
    public bool Rephrase { get; set; }

    /// <summary>Rephrase prompt given to the generative model responsible for rephrasing the query for a more effective retrieval step. This is only used if the `rephrase` flag is set to true in the request. If not specified, Nuclia's default prompt is used. It must include the {question} placeholder. The placeholder will be replaced with the original question</summary>
    public object RephrasePrompt { get; set; }

    /// <summary>Image that will be used together with the query text for retrieval.</summary>
    public object QueryImage { get; set; }

    /// <summary>Query for the knowledge graph. Paths (node-relation-node) extracted from a paragraph_id will be used to extend the results</summary>
    public object GraphQuery { get; set; }

    /// <summary>List of search features to use. Each value corresponds to a lookup into on of the different indexes</summary>
    public List<FindOptions> Features { get; set; }

    /// <summary>Rank fusion algorithm to use to merge results from multiple retrievers (keyword, semantic)</summary>
    public object RankFusion { get; set; }

    /// <summary>Reranker let you specify which method you want to use to rerank your results at the end of retrieval</summary>
    public object Reranker { get; set; }

    /// <summary>List of keyword filter expressions to apply to the retrieval step. The text block search will only be performed on the documents that contain the specified keywords. The filters are case-insensitive, and only alphanumeric characters and spaces are allowed. Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters</summary>
    public object KeywordFilters { get; set; }

    /// <summary>Load find parameters from this configuration. Parameters in the request override parameters from the configuration.</summary>
    public object SearchConfiguration { get; set; }

    /// <summary>The generative model used to rephrase the query. If not provided, the model configured for the Knowledge Box is used.</summary>
    public object GenerativeModel { get; set; }
}

/// <summary>FindResource</summary>
public class FindResource
{
    /// <summary>Id</summary>
    public string Id { get; set; }

    /// <summary>Slug</summary>
    public object Slug { get; set; }

    /// <summary>Title</summary>
    public object Title { get; set; }

    /// <summary>Summary</summary>
    public object Summary { get; set; }

    /// <summary>Icon</summary>
    public object Icon { get; set; }

    /// <summary>Thumbnail</summary>
    public object Thumbnail { get; set; }

    /// <summary>Metadata</summary>
    public object Metadata { get; set; }

    /// <summary>Usermetadata</summary>
    public object Usermetadata { get; set; }

    /// <summary>Fieldmetadata</summary>
    public object Fieldmetadata { get; set; }

    /// <summary>Computedmetadata</summary>
    public object Computedmetadata { get; set; }

    /// <summary>Created</summary>
    public object Created { get; set; }

    /// <summary>Modified</summary>
    public object Modified { get; set; }

    /// <summary>LastSeqid</summary>
    public object LastSeqid { get; set; }

    /// <summary>LastAccountSeq</summary>
    public object LastAccountSeq { get; set; }

    /// <summary>Queue</summary>
    public object Queue { get; set; }

    /// <summary>Hidden</summary>
    public object Hidden { get; set; }

    /// <summary>Origin</summary>
    public object Origin { get; set; }

    /// <summary>Extra</summary>
    public object Extra { get; set; }

    /// <summary>Relations</summary>
    public object Relations { get; set; }

    /// <summary>Data</summary>
    public object Data { get; set; }

    /// <summary>Resource security metadata</summary>
    public object Security { get; set; }

    /// <summary>Fields</summary>
    public object Fields { get; set; }
}

/// <summary>FullResourceApplyTo</summary>
public class FullResourceApplyTo
{
    /// <summary>Resources from matches containing any of these labels won't expand to the full resource. This may be useful to exclude long and not interesting resources and expend less tokens</summary>
    public List<string> Exclude { get; set; }
}

/// <summary>FullResourceStrategy</summary>
public class FullResourceStrategy
{
    /// <summary>Name</summary>
    public string Name { get; set; }

    /// <summary>Maximum number of full documents to retrieve. If not specified, all matching documents are retrieved.</summary>
    public object Count { get; set; }

    /// <summary>Whether to include the remaining text blocks after the maximum number of resources has been reached.</summary>
    public bool IncludeRemainingTextBlocks { get; set; }

    /// <summary>Define which resources to exclude from serialization</summary>
    public object ApplyTo { get; set; }
}

/// <summary>Generator</summary>
public class Generator
{

}

/// <summary>GenericFieldData</summary>
public class GenericFieldData
{
    /// <summary>Value</summary>
    public object Value { get; set; }

    /// <summary>Extracted</summary>
    public object Extracted { get; set; }

    /// <summary>Error</summary>
    public object Error { get; set; }

    /// <summary>Status</summary>
    public object Status { get; set; }

    /// <summary>Errors</summary>
    public object Errors { get; set; }
}

/// <summary>Returns only relations from documents that match this filter expression. Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters</summary>
public class GraphFilterExpression
{
    /// <summary>Filter to apply to fields</summary>
    public object Field { get; set; }
}

/// <summary>GraphNodeInput</summary>
public class GraphNodeInput
{
    /// <summary>Value</summary>
    public object Value { get; set; }

    /// <summary>Match</summary>
    public NodeMatchKindName Match { get; set; }

    /// <summary>Type</summary>
    public object Type { get; set; }

    /// <summary>Group</summary>
    public object Group { get; set; }
}

/// <summary>GraphNodeOutput</summary>
public class GraphNodeOutput
{
    /// <summary>Value</summary>
    public string Value { get; set; }

    /// <summary>Type</summary>
    public RelationNodeType Type { get; set; }

    /// <summary>Group</summary>
    public string Group { get; set; }
}

/// <summary>GraphNodesSearchRequest</summary>
public class GraphNodesSearchRequest
{
    /// <summary>TopK</summary>
    public int TopK { get; set; }

    /// <summary>Returns only relations from documents that match this filter expression.Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters</summary>
    public object FilterExpression { get; set; }

    /// <summary>Security metadata for the request. If not provided, the search request is done without the security lookup phase.</summary>
    public object Security { get; set; }

    /// <summary>If set to false (default), excludes hidden resources from search</summary>
    public bool ShowHidden { get; set; }

    /// <summary>Query</summary>
    public object Query { get; set; }
}

/// <summary>GraphNodesSearchResponse</summary>
public class GraphNodesSearchResponse
{
    /// <summary>Nodes</summary>
    public List<GraphNodeOutput> Nodes { get; set; }
}

/// <summary>GraphPathInput</summary>
public class GraphPathInput
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>Source</summary>
    public object Source { get; set; }

    /// <summary>Relation</summary>
    public object Relation { get; set; }

    /// <summary>Destination</summary>
    public object Destination { get; set; }

    /// <summary>Undirected</summary>
    public bool Undirected { get; set; }
}

/// <summary>GraphPathOutput</summary>
public class GraphPathOutput
{
    /// <summary>Source</summary>
    public GraphNodeOutput Source { get; set; }

    /// <summary>Relation</summary>
    public GraphRelationOutput Relation { get; set; }

    /// <summary>Destination</summary>
    public GraphNodeOutput Destination { get; set; }
}

/// <summary>GraphRelationInput</summary>
public class GraphRelationInput
{
    /// <summary>Label</summary>
    public object Label { get; set; }

    /// <summary>Type</summary>
    public object Type { get; set; }
}

/// <summary>GraphRelationOutput</summary>
public class GraphRelationOutput
{
    /// <summary>Label</summary>
    public string Label { get; set; }

    /// <summary>Type</summary>
    public RelationType Type { get; set; }
}

/// <summary>GraphRelationsSearchRequest</summary>
public class GraphRelationsSearchRequest
{
    /// <summary>TopK</summary>
    public int TopK { get; set; }

    /// <summary>Returns only relations from documents that match this filter expression.Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters</summary>
    public object FilterExpression { get; set; }

    /// <summary>Security metadata for the request. If not provided, the search request is done without the security lookup phase.</summary>
    public object Security { get; set; }

    /// <summary>If set to false (default), excludes hidden resources from search</summary>
    public bool ShowHidden { get; set; }

    /// <summary>Query</summary>
    public object Query { get; set; }
}

/// <summary>GraphRelationsSearchResponse</summary>
public class GraphRelationsSearchResponse
{
    /// <summary>Relations</summary>
    public List<GraphRelationOutput> Relations { get; set; }
}

/// <summary>GraphSearchRequest</summary>
public class GraphSearchRequest
{
    /// <summary>TopK</summary>
    public int TopK { get; set; }

    /// <summary>Returns only relations from documents that match this filter expression.Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters</summary>
    public object FilterExpression { get; set; }

    /// <summary>Security metadata for the request. If not provided, the search request is done without the security lookup phase.</summary>
    public object Security { get; set; }

    /// <summary>If set to false (default), excludes hidden resources from search</summary>
    public bool ShowHidden { get; set; }

    /// <summary>Query</summary>
    public object Query { get; set; }
}

/// <summary>GraphSearchResponse</summary>
public class GraphSearchResponse
{
    /// <summary>Paths</summary>
    public List<GraphPathOutput> Paths { get; set; }
}

/// <summary>This strategy retrieves context pieces by exploring the Knowledge Graph, starting from the entities present in the query. It works best if the Knowledge Box has a user-defined Graph Extraction agent enabled.</summary>
public class GraphStrategy
{
    /// <summary>Name</summary>
    public string Name { get; set; }

    /// <summary>Number of hops to take when exploring the graph for relevant context. For example, - hops=1 will explore the neighbors of the starting entities. - hops=2 will explore the neighbors of the neighbors of the starting entities. And so on. Bigger values will discover more intricate relationships but will also take more time to compute.</summary>
    public int Hops { get; set; }

    /// <summary>Number of relationships to keep after each hop after ranking them by relevance to the query. This number correlates to more paragraphs being sent as context. If not set, this number will be set to 30 if `relation_text_as_paragraphs` is set to false or 200 if `relation_text_as_paragraphs` is set to true.</summary>
    public int TopK { get; set; }

    /// <summary>If set to true, only relationships extracted from a graph extraction agent are considered for context expansion.</summary>
    public bool ExcludeProcessorRelations { get; set; }

    /// <summary>If set to true, the text of the relationships is to create context paragraphs, this enables to use bigger top K values without running into the generative model's context limits. If set to false, the paragraphs that contain the relationships are used as context.</summary>
    public bool RelationTextAsParagraphs { get; set; }

    /// <summary>RelationRanking</summary>
    public RelationRanking RelationRanking { get; set; }

    /// <summary>QueryEntityDetection</summary>
    public QueryEntityDetection QueryEntityDetection { get; set; }

    /// <summary>Weight of the graph strategy in the context. The weight is used to scale the results of the strategy before adding them to the context.The weight should be a positive number.</summary>
    public float Weight { get; set; }
}

/// <summary>HierarchyResourceStrategy</summary>
public class HierarchyResourceStrategy
{
    /// <summary>Name</summary>
    public string Name { get; set; }

    /// <summary>Number of extra characters that are added to each matching paragraph when adding to the context.</summary>
    public int Count { get; set; }
}

/// <summary>Image</summary>
public class Image
{
    /// <summary>ContentType</summary>
    public string ContentType { get; set; }

    /// <summary>B64encoded</summary>
    public string B64encoded { get; set; }
}

/// <summary>Matches all fields that contain a keyword</summary>
public class Keyword
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>Keyword to find</summary>
    public string Word { get; set; }
}

/// <summary>Matches paragraphs of a certain kind</summary>
public class Kind
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>KindValue</summary>
    public TypeParagraph KindValue { get; set; }
}

/// <summary>KnowledgeboxCounters</summary>
public class KnowledgeboxCounters
{
    /// <summary>Resources</summary>
    public int Resources { get; set; }

    /// <summary>Paragraphs</summary>
    public int Paragraphs { get; set; }

    /// <summary>Fields</summary>
    public int Fields { get; set; }

    /// <summary>Sentences</summary>
    public int Sentences { get; set; }

    /// <summary>Shards</summary>
    public object Shards { get; set; }

    /// <summary>IndexSize</summary>
    public float IndexSize { get; set; }
}

/// <summary>Find on knowledgebox results</summary>
public class KnowledgeboxFindResults
{
    /// <summary>Resources</summary>
    public object Resources { get; set; }

    /// <summary>Relations</summary>
    public object Relations { get; set; }

    /// <summary>Query</summary>
    public object Query { get; set; }

    /// <summary>RephrasedQuery</summary>
    public object RephrasedQuery { get; set; }

    /// <summary>Total</summary>
    public int Total { get; set; }

    /// <summary>Pagination will be deprecated, please, refer to `top_k` in the request</summary>
    public int PageNumber { get; set; }

    /// <summary>Pagination will be deprecated, please, refer to `top_k` in the request</summary>
    public int PageSize { get; set; }

    /// <summary>Pagination will be deprecated, please, refer to `top_k` in the request</summary>
    public bool NextPage { get; set; }

    /// <summary>List of nodes queried in the search</summary>
    public object Nodes { get; set; }

    /// <summary>The list of shard replica ids used for the search.</summary>
    public object Shards { get; set; }

    /// <summary>List of filters automatically applied to the search query</summary>
    public List<string> Autofilters { get; set; }

    /// <summary>The minimum scores that have been used for the search operation.</summary>
    public object MinScore { get; set; }

    /// <summary>List of ids of best matching paragraphs. The list is sorted by decreasing relevance (most relevant first).</summary>
    public List<string> BestMatches { get; set; }

    /// <summary>Metrics information about the search operation. The metadata included in this field is subject to change and should not be used in production. This is only available if the `debug` parameter is set to true in the request.</summary>
    public object Metrics { get; set; }
}

/// <summary>Search on knowledgebox results</summary>
public class KnowledgeboxSearchResults
{
    /// <summary>Resources</summary>
    public object Resources { get; set; }

    /// <summary>Sentences</summary>
    public object Sentences { get; set; }

    /// <summary>Paragraphs</summary>
    public object Paragraphs { get; set; }

    /// <summary>Fulltext</summary>
    public object Fulltext { get; set; }

    /// <summary>Relations</summary>
    public object Relations { get; set; }

    /// <summary>Nodes</summary>
    public object Nodes { get; set; }

    /// <summary>Shards</summary>
    public object Shards { get; set; }

    /// <summary>List of filters automatically applied to the search query</summary>
    public List<string> Autofilters { get; set; }
}

/// <summary>Suggest on resource results</summary>
public class KnowledgeboxSuggestResults
{
    /// <summary>Paragraphs</summary>
    public object Paragraphs { get; set; }

    /// <summary>Entities</summary>
    public object Entities { get; set; }

    /// <summary>Shards</summary>
    public object Shards { get; set; }
}

/// <summary>Matches fields/paragraphs with a label (or labelset)</summary>
public class Label
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>The labelset to match</summary>
    public string Labelset { get; set; }

    /// <summary>The label to match. If blank, matches all labels in the given labelset</summary>
    public object LabelValue { get; set; }
}

/// <summary>Matches the language of the field</summary>
public class Language
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>Match only the primary language of the document. By default, matches any language that appears in the document</summary>
    public bool OnlyPrimary { get; set; }

    /// <summary>The code of the language to match, e.g: en</summary>
    public string LanguageValue { get; set; }
}

/// <summary>LargeComputedMetadata</summary>
public class LargeComputedMetadata
{
    /// <summary>Metadata</summary>
    public object Metadata { get; set; }

    /// <summary>SplitMetadata</summary>
    public object SplitMetadata { get; set; }

    /// <summary>DeletedSplits</summary>
    public object DeletedSplits { get; set; }
}

/// <summary>LinkExtractedData</summary>
public class LinkExtractedData
{
    /// <summary>Date</summary>
    public object Date { get; set; }

    /// <summary>Language</summary>
    public object Language { get; set; }

    /// <summary>Title</summary>
    public object Title { get; set; }

    /// <summary>Metadata</summary>
    public object Metadata { get; set; }

    /// <summary>LinkThumbnail</summary>
    public object LinkThumbnail { get; set; }

    /// <summary>LinkPreview</summary>
    public object LinkPreview { get; set; }

    /// <summary>Field</summary>
    public object Field { get; set; }

    /// <summary>LinkImage</summary>
    public object LinkImage { get; set; }

    /// <summary>Description</summary>
    public object Description { get; set; }

    /// <summary>Type</summary>
    public object Type { get; set; }

    /// <summary>Embed</summary>
    public object Embed { get; set; }

    /// <summary>FileGenerated</summary>
    public object FileGenerated { get; set; }
}

/// <summary>LinkFieldData</summary>
public class LinkFieldData
{
    /// <summary>Value</summary>
    public object Value { get; set; }

    /// <summary>Extracted</summary>
    public object Extracted { get; set; }

    /// <summary>Error</summary>
    public object Error { get; set; }

    /// <summary>Status</summary>
    public object Status { get; set; }

    /// <summary>Errors</summary>
    public object Errors { get; set; }
}

/// <summary>LinkFieldExtractedData</summary>
public class LinkFieldExtractedData
{
    /// <summary>Text</summary>
    public object Text { get; set; }

    /// <summary>Metadata</summary>
    public object Metadata { get; set; }

    /// <summary>LargeMetadata</summary>
    public object LargeMetadata { get; set; }

    /// <summary>Vectors</summary>
    public object Vectors { get; set; }

    /// <summary>QuestionAnswers</summary>
    public object QuestionAnswers { get; set; }

    /// <summary>Link</summary>
    public object Link { get; set; }
}

/// <summary>MaxTokens</summary>
public class MaxTokens
{
    /// <summary>Use to limit the amount of tokens used in the LLM context</summary>
    public object Context { get; set; }

    /// <summary>Use to limit the amount of tokens used in the LLM answer</summary>
    public object Answer { get; set; }
}

/// <summary>Metadata</summary>
public class Metadata
{
    /// <summary>MetadataValue</summary>
    public object MetadataValue { get; set; }

    /// <summary>Language</summary>
    public object Language { get; set; }

    /// <summary>Languages</summary>
    public object Languages { get; set; }

    /// <summary>Status</summary>
    public ResourceProcessingStatus Status { get; set; }
}

/// <summary>RAG strategy to enrich the context with metadata of the matching paragraphs or its resources. This strategy can be combined with any of the other strategies.</summary>
public class MetadataExtensionStrategy
{
    /// <summary>Name</summary>
    public string Name { get; set; }

    /// <summary>List of resource metadata types to add to the context.   - 'origin': origin metadata of the resource.   - 'classification_labels': classification labels of the resource.   - 'ner': Named Entity Recognition entities detected for the resource.   - 'extra_metadata': extra metadata of the resource.  Types for which the metadata is not found at the resource are ignored and not added to the context.</summary>
    public List<MetadataExtensionType> Types { get; set; }
}

/// <summary>MetadataExtensionType</summary>
public class MetadataExtensionType
{

}

/// <summary>MinScore</summary>
public class MinScore
{
    /// <summary>Minimum semantic similarity score used to filter vector index search. If not specified, the default minimum score of the semantic model associated to the Knowledge Box will be used. Check out the documentation for more information on how to use this parameter: https://docs.nuclia.dev/docs/rag/advanced/search#minimum-score</summary>
    public object Semantic { get; set; }

    /// <summary>Minimum score used to filter bm25 index search. Check out the documentation for more information on how to use this parameter: https://docs.nuclia.dev/docs/rag/advanced/search#minimum-score</summary>
    public float Bm25 { get; set; }
}

/// <summary>NeighbouringParagraphsStrategy</summary>
public class NeighbouringParagraphsStrategy
{
    /// <summary>Name</summary>
    public string Name { get; set; }

    /// <summary>Number of previous neighbouring paragraphs to add to the context, for each matching paragraph in the retrieval step.</summary>
    public int Before { get; set; }

    /// <summary>Number of following neighbouring paragraphs to add to the context, for each matching paragraph in the retrieval step.</summary>
    public int After { get; set; }
}

/// <summary>NestedListPosition</summary>
public class NestedListPosition
{
    /// <summary>Positions</summary>
    public List<NestedPosition> Positions { get; set; }
}

/// <summary>NestedPosition</summary>
public class NestedPosition
{
    /// <summary>Start</summary>
    public object Start { get; set; }

    /// <summary>End</summary>
    public object End { get; set; }

    /// <summary>Page</summary>
    public object Page { get; set; }
}

/// <summary>NewTextField</summary>
public class NewTextField
{
    /// <summary>TextField</summary>
    public FieldText TextField { get; set; }

    /// <summary>Destination</summary>
    public string Destination { get; set; }
}

/// <summary>NodeMatchKindName</summary>
public class NodeMatchKindName
{

}

/// <summary>NotFieldFilterExpression</summary>
public class NotFieldFilterExpression
{

}

/// <summary>NotGraphNodesQuery</summary>
public class NotGraphNodesQuery
{
    /// <summary>Operand</summary>
    public object Operand { get; set; }
}

/// <summary>NotGraphPathQuery</summary>
public class NotGraphPathQuery
{

}

/// <summary>NotGraphRelationsQuery</summary>
public class NotGraphRelationsQuery
{
    /// <summary>Operand</summary>
    public object Operand { get; set; }
}

/// <summary>NotParagraphFilterExpression</summary>
public class NotParagraphFilterExpression
{

}

/// <summary>NotResourceFilterExpression</summary>
public class NotResourceFilterExpression
{
    /// <summary>Operand</summary>
    public object Operand { get; set; }
}

/// <summary>NucliaDBClientType</summary>
public class NucliaDBClientType
{

}

/// <summary>Operator</summary>
public class Operator
{

}

/// <summary>OrFieldFilterExpression</summary>
public class OrFieldFilterExpression
{

}

/// <summary>OrGraphNodesQuery</summary>
public class OrGraphNodesQuery
{
    /// <summary>Operands</summary>
    public List<object> Operands { get; set; }
}

/// <summary>OrGraphPathQuery</summary>
public class OrGraphPathQuery
{

}

/// <summary>OrGraphRelationsQuery</summary>
public class OrGraphRelationsQuery
{
    /// <summary>Operands</summary>
    public List<object> Operands { get; set; }
}

/// <summary>OrParagraphFilterExpression</summary>
public class OrParagraphFilterExpression
{

}

/// <summary>OrResourceFilterExpression</summary>
public class OrResourceFilterExpression
{
    /// <summary>Operands</summary>
    public List<object> Operands { get; set; }
}

/// <summary>Origin</summary>
public class Origin
{
    /// <summary>SourceId</summary>
    public object SourceId { get; set; }

    /// <summary>Url</summary>
    public object Url { get; set; }

    /// <summary>Created</summary>
    public object Created { get; set; }

    /// <summary>Modified</summary>
    public object Modified { get; set; }

    /// <summary>Generic metadata from the resource at the origin system. It can later be used for filtering on search endpoints with '/origin.metadata/{key}/{value}'</summary>
    public object Metadata { get; set; }

    /// <summary>Resource tags about the origin system. It can later be used for filtering on search endpoints with '/origin.tags/{tag}'</summary>
    public List<string> Tags { get; set; }

    /// <summary>Collaborators</summary>
    public List<string> Collaborators { get; set; }

    /// <summary>Filename</summary>
    public object Filename { get; set; }

    /// <summary>Related</summary>
    public List<string> Related { get; set; }

    /// <summary>Path of the original resource. Typically used to store folder structure information of the resource at the origin system. It can be later used for filtering on search endpoints with '/origin.path/{path}'</summary>
    public object Path { get; set; }

    /// <summary>Source</summary>
    public object Source { get; set; }
}

/// <summary>Matches the origin collaborators</summary>
public class OriginCollaborator
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>Collaborator</summary>
    public string Collaborator { get; set; }
}

/// <summary>Matches metadata from the origin</summary>
public class OriginMetadata
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>Metadata field</summary>
    public string Field { get; set; }

    /// <summary>Value of the metadata field. If blank, matches any document with the given metadata field set (to any value)</summary>
    public object Value { get; set; }
}

/// <summary>Matches the origin path</summary>
public class OriginPath
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>Prefix of the path, matches all paths under this prefixe.g: `prefix=/dir/` matches `/dir` and `/dir/a/b` but not `/dirrrr`</summary>
    public object Prefix { get; set; }
}

/// <summary>Matches the origin source id</summary>
public class OriginSource
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>Source ID</summary>
    public object Id { get; set; }
}

/// <summary>Matches all fields with a given origin tag</summary>
public class OriginTag
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>The tag to match</summary>
    public string Tag { get; set; }
}

/// <summary>PageImageStrategy</summary>
public class PageImageStrategy
{
    /// <summary>Name</summary>
    public string Name { get; set; }

    /// <summary>Maximum number of images to retrieve from the page. By default, at most 5 images are retrieved.</summary>
    public object Count { get; set; }
}

/// <summary>PageInformation</summary>
public class PageInformation
{
    /// <summary>Page</summary>
    public object Page { get; set; }

    /// <summary>PageWithVisual</summary>
    public object PageWithVisual { get; set; }
}

/// <summary>PagePositions</summary>
public class PagePositions
{
    /// <summary>Start</summary>
    public object Start { get; set; }

    /// <summary>End</summary>
    public object End { get; set; }
}

/// <summary>PageStructure</summary>
public class PageStructure
{
    /// <summary>Page</summary>
    public PageStructurePage Page { get; set; }

    /// <summary>Tokens</summary>
    public List<PageStructureToken> Tokens { get; set; }
}

/// <summary>PageStructurePage</summary>
public class PageStructurePage
{
    /// <summary>Width</summary>
    public int Width { get; set; }

    /// <summary>Height</summary>
    public int Height { get; set; }
}

/// <summary>PageStructureToken</summary>
public class PageStructureToken
{
    /// <summary>X</summary>
    public float X { get; set; }

    /// <summary>Y</summary>
    public float Y { get; set; }

    /// <summary>Width</summary>
    public float Width { get; set; }

    /// <summary>Height</summary>
    public float Height { get; set; }

    /// <summary>Text</summary>
    public string Text { get; set; }

    /// <summary>Line</summary>
    public float Line { get; set; }
}

/// <summary>ParagraphAnnotation</summary>
public class ParagraphAnnotation
{
    /// <summary>Classifications</summary>
    public List<UserClassification> Classifications { get; set; }

    /// <summary>Key</summary>
    public string Key { get; set; }
}

/// <summary>ParagraphImageStrategy</summary>
public class ParagraphImageStrategy
{
    /// <summary>Name</summary>
    public string Name { get; set; }
}

/// <summary>ParagraphRelations</summary>
public class ParagraphRelations
{
    /// <summary>Parents</summary>
    public List<string> Parents { get; set; }

    /// <summary>Siblings</summary>
    public List<string> Siblings { get; set; }

    /// <summary>Replacements</summary>
    public List<string> Replacements { get; set; }
}

/// <summary>Paragraphs</summary>
public class Paragraphs
{
    /// <summary>Results</summary>
    public List<NucliadbModelsSearchParagraph> Results { get; set; }

    /// <summary>Facets</summary>
    public object Facets { get; set; }

    /// <summary>Query</summary>
    public object Query { get; set; }

    /// <summary>Total</summary>
    public int Total { get; set; }

    /// <summary>PageNumber</summary>
    public int PageNumber { get; set; }

    /// <summary>PageSize</summary>
    public int PageSize { get; set; }

    /// <summary>NextPage</summary>
    public bool NextPage { get; set; }

    /// <summary>Minimum bm25 score used to filter bm25 index search. Results with a lower score have been ignored.</summary>
    public float MinScore { get; set; }
}

/// <summary>Position</summary>
public class Position
{
    /// <summary>Start</summary>
    public int Start { get; set; }

    /// <summary>End</summary>
    public int End { get; set; }
}

/// <summary>Positions</summary>
public class Positions
{
    /// <summary>Position</summary>
    public List<Position> Position { get; set; }

    /// <summary>Entity</summary>
    public string Entity { get; set; }
}

/// <summary>This strategy allows to run a set of queries before the main query and add the results to the context. It allows to give more importance to some queries over others by setting the weight of each query. The weight of the main query can also be set with the `main_query_weight` parameter.</summary>
public class PreQueriesStrategy
{
    /// <summary>Name</summary>
    public string Name { get; set; }

    /// <summary>List of queries to run before the main query. The results are added to the context with the specified weights for each query. There is a limit of 10 prequeries per request.</summary>
    public List<PreQuery> Queries { get; set; }

    /// <summary>Weight of the main query in the context. Use this to control the importance of the main query in the context.</summary>
    public float MainQueryWeight { get; set; }
}

/// <summary>PreQuery</summary>
public class PreQuery
{
    /// <summary>Request</summary>
    public FindRequest Request { get; set; }

    /// <summary>Weight of the prequery in the context. The weight is used to scale the results of the prequery before adding them to the context.The weight should be a positive number, and they are normalized so that the sum of all weights for all prequeries is 1.</summary>
    public float Weight { get; set; }

    /// <summary>Identifier of the prequery. If not specified, it is autogenerated based on the index of the prequery in the list (prequery_0, prequery_1, ...).</summary>
    public object Id { get; set; }

    /// <summary>If set to true, the prequery results are used to filter the scope of the remaining queries. The resources of the most relevant paragraphs of the prefilter queries are used as resource filters for the main query and other prequeries with the prefilter flag set to false.</summary>
    public bool Prefilter { get; set; }
}

/// <summary>Enum for the different endpoints that are proxied to the Predict API</summary>
public class PredictProxiedEndpoints
{

}

/// <summary>PredictReranker</summary>
public class PredictReranker
{
    /// <summary>Name</summary>
    public string Name { get; set; }

    /// <summary>Number of elements reranker will use. Window must be greater or equal to top_k. Greater values will improve results at cost of retrieval and reranking time. By default, this reranker uses a default of 2 times top_k</summary>
    public object Window { get; set; }
}

/// <summary>QueryEntityDetection</summary>
public class QueryEntityDetection
{

}

/// <summary>Question</summary>
public class Question
{
    /// <summary>Text</summary>
    public string Text { get; set; }

    /// <summary>Language</summary>
    public object Language { get; set; }

    /// <summary>IdsParagraphs</summary>
    public List<string> IdsParagraphs { get; set; }
}

/// <summary>QuestionAnswer</summary>
public class QuestionAnswer
{
    /// <summary>Question</summary>
    public Question Question { get; set; }

    /// <summary>Answers</summary>
    public List<Answer> Answers { get; set; }
}

/// <summary>QuestionAnswerAnnotation</summary>
public class QuestionAnswerAnnotation
{
    /// <summary>QuestionAnswer</summary>
    public QuestionAnswer QuestionAnswer { get; set; }

    /// <summary>CancelledByUser</summary>
    public bool CancelledByUser { get; set; }
}

/// <summary>QuestionAnswers</summary>
public class QuestionAnswers
{
    /// <summary>QuestionAnswer</summary>
    public List<QuestionAnswer> QuestionAnswer { get; set; }
}

/// <summary>QueueType</summary>
public class QueueType
{

}

/// <summary>RankFusionName</summary>
public class RankFusionName
{

}

/// <summary>Reasoning</summary>
public class Reasoning
{
    /// <summary>Whether to display the reasoning steps in the response.</summary>
    public bool Display { get; set; }

    /// <summary>Level of reasoning effort. Used by OpenAI models to control the depth of reasoning. This parameter will be automatically mapped to budget_tokens if the chosen model does not support effort.</summary>
    public string Effort { get; set; }

    /// <summary>Token budget for reasoning. Used by Anthropic or Google models to limit the number of tokens used for reasoning. This parameter will be automatically mapped to effort if the chosen model does not support budget_tokens.</summary>
    public int BudgetTokens { get; set; }
}

/// <summary>ReciprocalRankFusion</summary>
public class ReciprocalRankFusion
{
    /// <summary>Name</summary>
    public string Name { get; set; }

    /// <summary>k parameter changes the influence top-ranked and lower-ranked elements have. Research has shown that 60 is a performant value across datasets</summary>
    public float K { get; set; }

    /// <summary>Number of elements for retrieval to do RRF. Window must be greater or equal to top_k. Greater values will increase probability of multi match at cost of retrieval time</summary>
    public object Window { get; set; }

    /// <summary>Boosting</summary>
    public ReciprocalRankFusionWeights Boosting { get; set; }
}

/// <summary>ReciprocalRankFusionWeights</summary>
public class ReciprocalRankFusionWeights
{
    /// <summary>Keyword</summary>
    public float Keyword { get; set; }

    /// <summary>Semantic</summary>
    public float Semantic { get; set; }
}

/// <summary>RelatedEntities</summary>
public class RelatedEntities
{
    /// <summary>Total</summary>
    public int Total { get; set; }

    /// <summary>Entities</summary>
    public List<RelatedEntity> Entities { get; set; }
}

/// <summary>RelatedEntity</summary>
public class RelatedEntity
{
    /// <summary>Family</summary>
    public string Family { get; set; }

    /// <summary>Value</summary>
    public string Value { get; set; }
}

/// <summary>RelationInput</summary>
public class RelationInput
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>Label</summary>
    public object Label { get; set; }

    /// <summary>Type</summary>
    public object Type { get; set; }
}

/// <summary>RelationOutput</summary>
public class RelationOutput
{
    /// <summary>Relation</summary>
    public RelationType Relation { get; set; }

    /// <summary>Label</summary>
    public object Label { get; set; }

    /// <summary>Metadata</summary>
    public object Metadata { get; set; }

    /// <summary>From</summary>
    public object From { get; set; }

    /// <summary>To</summary>
    public RelationEntity To { get; set; }
}

/// <summary>RelationDirection</summary>
public class RelationDirection
{

}

/// <summary>RelationEntity</summary>
public class RelationEntity
{
    /// <summary>Value</summary>
    public string Value { get; set; }

    /// <summary>Type</summary>
    public RelationNodeType Type { get; set; }

    /// <summary>Group</summary>
    public object Group { get; set; }
}

/// <summary>RelationMetadata</summary>
public class RelationMetadata
{
    /// <summary>ParagraphId</summary>
    public object ParagraphId { get; set; }

    /// <summary>SourceStart</summary>
    public object SourceStart { get; set; }

    /// <summary>SourceEnd</summary>
    public object SourceEnd { get; set; }

    /// <summary>ToStart</summary>
    public object ToStart { get; set; }

    /// <summary>ToEnd</summary>
    public object ToEnd { get; set; }

    /// <summary>DataAugmentationTaskId</summary>
    public object DataAugmentationTaskId { get; set; }
}

/// <summary>RelationNodeType</summary>
public class RelationNodeType
{

}

/// <summary>RelationRanking</summary>
public class RelationRanking
{

}

/// <summary>RelationType</summary>
public class RelationType
{

}

/// <summary>Relations</summary>
public class Relations
{
    /// <summary>Entities</summary>
    public object Entities { get; set; }
}

/// <summary>Representation</summary>
public class Representation
{
    /// <summary>IsATable</summary>
    public object IsATable { get; set; }

    /// <summary>ReferenceFile</summary>
    public object ReferenceFile { get; set; }
}

/// <summary>Security metadata for the search request</summary>
public class RequestSecurity
{
    /// <summary>List of group ids to do the request with.</summary>
    public List<string> Groups { get; set; }
}

/// <summary>Rerankers  - Predict reranker: after retrieval, send the results to Predict API to   rerank it. This method uses a reranker model, so one can expect better   results at the expense of more latency.    This will be the new default  - No-operation (noop) reranker: maintain order and do not rerank the results   after retrieval</summary>
public class RerankerName
{

}

/// <summary>Matches all fields of a resource given its id or slug</summary>
public class ResourceInput
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>UUID of the resource to match</summary>
    public object Id { get; set; }

    /// <summary>Slug of the resource to match</summary>
    public object Slug { get; set; }
}

/// <summary>ResourceOutput</summary>
public class ResourceOutput
{
    /// <summary>Id</summary>
    public string Id { get; set; }

    /// <summary>Slug</summary>
    public object Slug { get; set; }

    /// <summary>Title</summary>
    public object Title { get; set; }

    /// <summary>Summary</summary>
    public object Summary { get; set; }

    /// <summary>Icon</summary>
    public object Icon { get; set; }

    /// <summary>Thumbnail</summary>
    public object Thumbnail { get; set; }

    /// <summary>Metadata</summary>
    public object Metadata { get; set; }

    /// <summary>Usermetadata</summary>
    public object Usermetadata { get; set; }

    /// <summary>Fieldmetadata</summary>
    public object Fieldmetadata { get; set; }

    /// <summary>Computedmetadata</summary>
    public object Computedmetadata { get; set; }

    /// <summary>Created</summary>
    public object Created { get; set; }

    /// <summary>Modified</summary>
    public object Modified { get; set; }

    /// <summary>LastSeqid</summary>
    public object LastSeqid { get; set; }

    /// <summary>LastAccountSeq</summary>
    public object LastAccountSeq { get; set; }

    /// <summary>Queue</summary>
    public object Queue { get; set; }

    /// <summary>Hidden</summary>
    public object Hidden { get; set; }

    /// <summary>Origin</summary>
    public object Origin { get; set; }

    /// <summary>Extra</summary>
    public object Extra { get; set; }

    /// <summary>Relations</summary>
    public object Relations { get; set; }

    /// <summary>Data</summary>
    public object Data { get; set; }

    /// <summary>Resource security metadata</summary>
    public object Security { get; set; }
}

/// <summary>ResourceAgentsRequest</summary>
public class ResourceAgentsRequest
{
    /// <summary>Filters to apply to the agents. If None, all curently configured agents are applied.</summary>
    public object Filters { get; set; }

    /// <summary>AgentIds</summary>
    public object AgentIds { get; set; }
}

/// <summary>ResourceAgentsResponse</summary>
public class ResourceAgentsResponse
{
    /// <summary>Results</summary>
    public object Results { get; set; }
}

/// <summary>ResourceData</summary>
public class ResourceData
{
    /// <summary>Texts</summary>
    public object Texts { get; set; }

    /// <summary>Files</summary>
    public object Files { get; set; }

    /// <summary>Links</summary>
    public object Links { get; set; }

    /// <summary>Conversations</summary>
    public object Conversations { get; set; }

    /// <summary>Generics</summary>
    public object Generics { get; set; }
}

/// <summary>Matches resources with a mimetype.  The mimetype of a resource can be assigned independently of the mimetype of its fields. In resources with multiple fields, you may prefer to use `field_mimetype`</summary>
public class ResourceMimetype
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>Type of the mimetype to match. e.g: In image/jpeg, type is image</summary>
    public string Type { get; set; }

    /// <summary>Type of the mimetype to match. e.g: In image/jpeg, subtype is jpeg.Leave blank to match all mimetype of the type</summary>
    public object Subtype { get; set; }
}

/// <summary>ResourceProcessingStatus</summary>
public class ResourceProcessingStatus
{

}

/// <summary>ResourceProperties</summary>
public class ResourceProperties
{

}

/// <summary>ResourceResult</summary>
public class ResourceResult
{
    /// <summary>Score</summary>
    public object Score { get; set; }

    /// <summary>Rid</summary>
    public string Rid { get; set; }

    /// <summary>FieldType</summary>
    public string FieldType { get; set; }

    /// <summary>Field</summary>
    public string Field { get; set; }

    /// <summary>Labels</summary>
    public object Labels { get; set; }
}

/// <summary>Search on resource results</summary>
public class ResourceSearchResults
{
    /// <summary>Sentences</summary>
    public object Sentences { get; set; }

    /// <summary>Paragraphs</summary>
    public object Paragraphs { get; set; }

    /// <summary>Relations</summary>
    public object Relations { get; set; }

    /// <summary>Nodes</summary>
    public object Nodes { get; set; }

    /// <summary>Shards</summary>
    public object Shards { get; set; }
}

/// <summary>Security metadata for the resource</summary>
public class ResourceSecurity
{
    /// <summary>List of group ids that can access the resource.</summary>
    public List<string> AccessGroups { get; set; }
}

/// <summary>Resources</summary>
public class Resources
{
    /// <summary>Results</summary>
    public List<ResourceResult> Results { get; set; }

    /// <summary>Facets</summary>
    public object Facets { get; set; }

    /// <summary>Query</summary>
    public object Query { get; set; }

    /// <summary>Total</summary>
    public int Total { get; set; }

    /// <summary>PageNumber</summary>
    public int PageNumber { get; set; }

    /// <summary>PageSize</summary>
    public int PageSize { get; set; }

    /// <summary>NextPage</summary>
    public bool NextPage { get; set; }

    /// <summary>Minimum bm25 score used to filter bm25 index search. Results with a lower score have been ignored.</summary>
    public float MinScore { get; set; }
}

/// <summary>Row</summary>
public class Row
{
    /// <summary>Cell</summary>
    public object Cell { get; set; }
}

/// <summary>RowsPreview</summary>
public class RowsPreview
{
    /// <summary>Sheets</summary>
    public object Sheets { get; set; }
}

/// <summary>SCORETYPE</summary>
public class SCORETYPE
{

}

/// <summary>SearchOptions</summary>
public class SearchOptions
{

}

/// <summary>SearchRequest</summary>
public class SearchRequest
{
    /// <summary>A dictionary containing optional audit-specific metadata, such as user_id, environment, or other contextual information. This metadata can be leveraged for filtering and analyzing activity logs in future operations. Each key-value pair represents a piece of metadata relevant to the user's request.</summary>
    public object AuditMetadata { get; set; }

    /// <summary>The query to search for</summary>
    public string Query { get; set; }

    /// <summary>Returns only documents that match this filter expression.Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters This allows building complex filtering expressions and replaces the following parameters:`fields`, `filters`, `range_*`, `resource_filters`, `keyword_filters`.</summary>
    public object FilterExpression { get; set; }

    /// <summary>The list of fields to search in. For instance: `a/title` to search only on title field. For more details on filtering by field, see: https://docs.nuclia.dev/docs/rag/advanced/search/#search-in-a-specific-field.</summary>
    public List<string> Fields { get; set; }

    /// <summary>The list of filters to apply. Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters</summary>
    public object Filters { get; set; }

    /// <summary>The number of results search should return. The maximum number of results allowed is 200.</summary>
    public int TopK { get; set; }

    /// <summary>Minimum score to filter search results. Results with a lower score will be ignored. Accepts either a float or a dictionary with the minimum scores for the bm25 and vector indexes. If a float is provided, it is interpreted as the minimum score for vector index search.</summary>
    public object MinScore { get; set; }

    /// <summary>Resources created before this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</summary>
    public object RangeCreationStart { get; set; }

    /// <summary>Resources created after this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</summary>
    public object RangeCreationEnd { get; set; }

    /// <summary>Resources modified before this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</summary>
    public object RangeModificationStart { get; set; }

    /// <summary>Resources modified after this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</summary>
    public object RangeModificationEnd { get; set; }

    /// <summary>If set, the response will include some extra metadata for debugging purposes, like the list of queried nodes.</summary>
    public bool Debug { get; set; }

    /// <summary>If set to true, the query terms will be highlighted in the results between <mark>...</mark> tags</summary>
    public bool Highlight { get; set; }

    /// <summary>Controls which types of metadata are serialized on resources of search results</summary>
    public List<ResourceProperties> Show { get; set; }

    /// <summary>Define which field types are serialized on resources of search results</summary>
    public List<FieldTypeName> FieldTypeFilter { get; set; }

    /// <summary>[Deprecated] Please use GET resource endpoint instead to get extracted metadata</summary>
    public List<ExtractedDataTypeName> Extracted { get; set; }

    /// <summary>The vector to perform the search with. If not provided, NucliaDB will use Nuclia Predict API to create the vector off from the query.</summary>
    public object Vector { get; set; }

    /// <summary>Vectors index to perform the search in. If not provided, NucliaDB will use the default one</summary>
    public object Vectorset { get; set; }

    /// <summary>Whether to return duplicate paragraphs on the same document</summary>
    public bool WithDuplicates { get; set; }

    /// <summary>Whether to return matches for custom knowledge box synonyms of the query terms. Note: only supported for `keyword` and `fulltext` search options.</summary>
    public bool WithSynonyms { get; set; }

    /// <summary>If set to true, the search will automatically add filters to the query. For example, it will filter results containing the entities detected in the query</summary>
    public bool Autofilter { get; set; }

    /// <summary>List of resource ids to filter search results for. Only paragraphs from the specified resources will be returned.</summary>
    public List<string> ResourceFilters { get; set; }

    /// <summary>Security metadata for the request. If not provided, the search request is done without the security lookup phase.</summary>
    public object Security { get; set; }

    /// <summary>If set to false (default), excludes hidden resources from search</summary>
    public bool ShowHidden { get; set; }

    /// <summary>Rephrase the query for a more efficient retrieval. This will consume LLM tokens and make the request slower.</summary>
    public bool Rephrase { get; set; }

    /// <summary>Rephrase prompt given to the generative model responsible for rephrasing the query for a more effective retrieval step. This is only used if the `rephrase` flag is set to true in the request. If not specified, Nuclia's default prompt is used. It must include the {question} placeholder. The placeholder will be replaced with the original question</summary>
    public object RephrasePrompt { get; set; }

    /// <summary>Image that will be used together with the query text for retrieval.</summary>
    public object QueryImage { get; set; }

    /// <summary>List of search features to use. Each value corresponds to a lookup into on of the different indexes</summary>
    public List<SearchOptions> Features { get; set; }

    /// <summary>The list of facets to calculate. The facets follow the same syntax as filters: https://docs.nuclia.dev/docs/rag/advanced/search-filters</summary>
    public List<string> Faceted { get; set; }

    /// <summary>Options for results sorting</summary>
    public object Sort { get; set; }
}

/// <summary>Sentences</summary>
public class Sentences
{
    /// <summary>Results</summary>
    public List<NucliadbModelsSearchSentence> Results { get; set; }

    /// <summary>Facets</summary>
    public object Facets { get; set; }

    /// <summary>PageNumber</summary>
    public int PageNumber { get; set; }

    /// <summary>PageSize</summary>
    public int PageSize { get; set; }

    /// <summary>Minimum similarity score used to filter vector index search. Results with a lower score have been ignored.</summary>
    public float MinScore { get; set; }
}

/// <summary>Sheet</summary>
public class Sheet
{
    /// <summary>Rows</summary>
    public object Rows { get; set; }
}

/// <summary>SortField</summary>
public class SortField
{

}

/// <summary>SortOptions</summary>
public class SortOptions
{
    /// <summary>Field</summary>
    public SortField Field { get; set; }

    /// <summary>Limit</summary>
    public object Limit { get; set; }

    /// <summary>Order</summary>
    public SortOrder Order { get; set; }
}

/// <summary>SortOrder</summary>
public class SortOrder
{

}

/// <summary>Source</summary>
public class Source
{

}

/// <summary>SourceNode</summary>
public class SourceNode
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>Value</summary>
    public object Value { get; set; }

    /// <summary>Match</summary>
    public NodeMatchKindName Match { get; set; }

    /// <summary>Type</summary>
    public object Type { get; set; }

    /// <summary>Group</summary>
    public object Group { get; set; }
}

/// <summary>Status</summary>
public class Status
{

}

/// <summary>SuggestOptions</summary>
public class SuggestOptions
{

}

/// <summary>Model for the request payload of the summarize endpoint</summary>
public class SummarizeRequest
{
    /// <summary>The generative model to use for the summarization. If not provided, the model configured for the Knowledge Box is used.</summary>
    public object GenerativeModel { get; set; }

    /// <summary>Optional custom prompt input by the user</summary>
    public object UserPrompt { get; set; }

    /// <summary>Uids or slugs of the resources to summarize. If the resources are not found, they will be ignored.</summary>
    public List<string> Resources { get; set; }

    /// <summary>SummaryKind</summary>
    public SummaryKind SummaryKind { get; set; }
}

/// <summary>SummarizedResource</summary>
public class SummarizedResource
{
    /// <summary>Summary of the resource</summary>
    public string Summary { get; set; }

    /// <summary>Tokens</summary>
    public int Tokens { get; set; }
}

/// <summary>SummarizedResponse</summary>
public class SummarizedResponse
{
    /// <summary>Individual resource summaries. The key is the resource id or slug.</summary>
    public object Resources { get; set; }

    /// <summary>Global summary of all resources combined.</summary>
    public string Summary { get; set; }

    /// <summary>Consumption</summary>
    public object Consumption { get; set; }
}

/// <summary>SummaryKind</summary>
public class SummaryKind
{

}

/// <summary>SyncAskMetadata</summary>
public class SyncAskMetadata
{
    /// <summary>Number of tokens used in the LLM context and answer</summary>
    public object Tokens { get; set; }

    /// <summary>Timings of the generative model</summary>
    public object Timings { get; set; }
}

/// <summary>SyncAskResponse</summary>
public class SyncAskResponse
{
    /// <summary>The generative answer to the query</summary>
    public string Answer { get; set; }

    /// <summary>The reasoning steps followed by the LLM to generate the answer. This is returned only if the reasoning feature is enabled in the request.</summary>
    public object Reasoning { get; set; }

    /// <summary>The generative JSON answer to the query. This is returned only if the answer_json_schema parameter is provided in the request.</summary>
    public object AnswerJson { get; set; }

    /// <summary>The status of the query execution. It can be 'success', 'error', 'no_context' or 'no_retrieval_data'</summary>
    public string Status { get; set; }

    /// <summary>RetrievalResults</summary>
    public KnowledgeboxFindResults RetrievalResults { get; set; }

    /// <summary>Sorted list of best matching text blocks in the retrieval step. This includes the main query and prequeries results, if any.</summary>
    public List<AskRetrievalMatch> RetrievalBestMatches { get; set; }

    /// <summary>The retrieval results of the prequeries</summary>
    public object Prequeries { get; set; }

    /// <summary>The id of the learning request. This id can be used to provide feedback on the learning process.</summary>
    public string LearningId { get; set; }

    /// <summary>The detected relations of the answer</summary>
    public object Relations { get; set; }

    /// <summary>The citations of the answer. List of references to the resources used to generate the answer.</summary>
    public object Citations { get; set; }

    /// <summary>Augmented text blocks that were sent to the LLM as part of the RAG strategies applied on the retrieval results in the request.</summary>
    public object AugmentedContext { get; set; }

    /// <summary>The prompt context used to generate the answer. Returned only if the debug flag is set to true</summary>
    public object PromptContext { get; set; }

    /// <summary>The internal predict request used to generate the answer. Returned only if the debug flag is set to true</summary>
    public object PredictRequest { get; set; }

    /// <summary>Metadata of the query execution. This includes the number of tokens used in the LLM context and answer, and the timings of the generative model.</summary>
    public object Metadata { get; set; }

    /// <summary>The consumption of the query execution. Return only if 'X-show-consumption' header is set to true in the request.</summary>
    public object Consumption { get; set; }

    /// <summary>Error details message in case there was an error</summary>
    public object ErrorDetails { get; set; }

    /// <summary>Debug information about the ask operation. The metadata included in this field is subject to change and should not be used in production. Note that it is only available if the `debug` parameter is set to true in the request.</summary>
    public object Debug { get; set; }
}

/// <summary>TableImageStrategy</summary>
public class TableImageStrategy
{
    /// <summary>Name</summary>
    public string Name { get; set; }
}

/// <summary>TextBlockAugmentationType</summary>
public class TextBlockAugmentationType
{

}

/// <summary>TextFieldData</summary>
public class TextFieldData
{
    /// <summary>Value</summary>
    public object Value { get; set; }

    /// <summary>Extracted</summary>
    public object Extracted { get; set; }

    /// <summary>Error</summary>
    public object Error { get; set; }

    /// <summary>Status</summary>
    public object Status { get; set; }

    /// <summary>Errors</summary>
    public object Errors { get; set; }
}

/// <summary>TextFieldExtractedData</summary>
public class TextFieldExtractedData
{
    /// <summary>Text</summary>
    public object Text { get; set; }

    /// <summary>Metadata</summary>
    public object Metadata { get; set; }

    /// <summary>LargeMetadata</summary>
    public object LargeMetadata { get; set; }

    /// <summary>Vectors</summary>
    public object Vectors { get; set; }

    /// <summary>QuestionAnswers</summary>
    public object QuestionAnswers { get; set; }
}

/// <summary>TextFormat</summary>
public class TextFormat
{

}

/// <summary>TextPosition</summary>
public class TextPosition
{
    /// <summary>PageNumber</summary>
    public object PageNumber { get; set; }

    /// <summary>Index</summary>
    public int Index { get; set; }

    /// <summary>Start</summary>
    public int Start { get; set; }

    /// <summary>End</summary>
    public int End { get; set; }

    /// <summary>StartSeconds</summary>
    public object StartSeconds { get; set; }

    /// <summary>EndSeconds</summary>
    public object EndSeconds { get; set; }
}

/// <summary>TokensDetail</summary>
public class TokensDetail
{
    /// <summary>Input</summary>
    public float Input { get; set; }

    /// <summary>Output</summary>
    public float Output { get; set; }

    /// <summary>Image</summary>
    public float Image { get; set; }
}

/// <summary>TypeParagraph</summary>
public class TypeParagraph
{

}

/// <summary>UserClassification</summary>
public class UserClassification
{
    /// <summary>Labelset</summary>
    public string Labelset { get; set; }

    /// <summary>Label</summary>
    public string Label { get; set; }

    /// <summary>CancelledByUser</summary>
    public bool CancelledByUser { get; set; }
}

/// <summary>Field-level metadata set by the user via the rest api</summary>
public class UserFieldMetadata
{
    /// <summary>Paragraphs</summary>
    public List<ParagraphAnnotation> Paragraphs { get; set; }

    /// <summary>QuestionAnswers</summary>
    public List<QuestionAnswerAnnotation> QuestionAnswers { get; set; }

    /// <summary>Field</summary>
    public FieldID Field { get; set; }
}

/// <summary>UserMetadata</summary>
public class UserMetadata
{
    /// <summary>Classifications</summary>
    public List<UserClassification> Classifications { get; set; }

    /// <summary>Relations</summary>
    public List<NucliadbModelsMetadataRelation> Relations { get; set; }
}

/// <summary>Vector</summary>
public class Vector
{
    /// <summary>Start</summary>
    public object Start { get; set; }

    /// <summary>End</summary>
    public object End { get; set; }

    /// <summary>StartParagraph</summary>
    public object StartParagraph { get; set; }

    /// <summary>EndParagraph</summary>
    public object EndParagraph { get; set; }

    /// <summary>VectorValue</summary>
    public object VectorValue { get; set; }
}

/// <summary>VectorObject</summary>
public class VectorObject
{
    /// <summary>Vectors</summary>
    public object Vectors { get; set; }

    /// <summary>SplitVectors</summary>
    public object SplitVectors { get; set; }

    /// <summary>DeletedSplits</summary>
    public object DeletedSplits { get; set; }
}

/// <summary>Vectors</summary>
public class Vectors
{
    /// <summary>VectorsValue</summary>
    public object VectorsValue { get; set; }
}

/// <summary>NucliadbModelsCommonParagraph</summary>
public class NucliadbModelsCommonParagraph
{
    /// <summary>Start</summary>
    public object Start { get; set; }

    /// <summary>End</summary>
    public object End { get; set; }

    /// <summary>StartSeconds</summary>
    public object StartSeconds { get; set; }

    /// <summary>EndSeconds</summary>
    public object EndSeconds { get; set; }

    /// <summary>Kind</summary>
    public object Kind { get; set; }

    /// <summary>Classifications</summary>
    public object Classifications { get; set; }

    /// <summary>Sentences</summary>
    public object Sentences { get; set; }

    /// <summary>Key</summary>
    public object Key { get; set; }

    /// <summary>Page</summary>
    public object Page { get; set; }

    /// <summary>Representation</summary>
    public object Representation { get; set; }

    /// <summary>Relations</summary>
    public object Relations { get; set; }
}

/// <summary>NucliadbModelsCommonSentence</summary>
public class NucliadbModelsCommonSentence
{
    /// <summary>Start</summary>
    public object Start { get; set; }

    /// <summary>End</summary>
    public object End { get; set; }

    /// <summary>Key</summary>
    public object Key { get; set; }
}

/// <summary>Matches if the field was generated by the given source</summary>
public class NucliadbModelsFiltersGenerated
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>Generator for this field. Currently, only data-augmentation is supported</summary>
    public string By { get; set; }

    /// <summary>Matches field generated by an specific DA task, given its prefix</summary>
    public object DaTask { get; set; }
}

/// <summary>Matches if the relation was generated by the given source</summary>
public class NucliadbModelsGraphRequestsGenerated
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>By</summary>
    public Generator By { get; set; }

    /// <summary>Matches relations generated by an specific DA task, given its prefix</summary>
    public object DaTask { get; set; }
}

/// <summary>NucliadbModelsSearchParagraph</summary>
public class NucliadbModelsSearchParagraph
{
    /// <summary>Score</summary>
    public float Score { get; set; }

    /// <summary>Rid</summary>
    public string Rid { get; set; }

    /// <summary>FieldType</summary>
    public string FieldType { get; set; }

    /// <summary>Field</summary>
    public string Field { get; set; }

    /// <summary>Text</summary>
    public string Text { get; set; }

    /// <summary>Labels</summary>
    public List<string> Labels { get; set; }

    /// <summary>StartSeconds</summary>
    public object StartSeconds { get; set; }

    /// <summary>EndSeconds</summary>
    public object EndSeconds { get; set; }

    /// <summary>Position</summary>
    public object Position { get; set; }

    /// <summary>FuzzyResult</summary>
    public bool FuzzyResult { get; set; }
}

/// <summary>NucliadbModelsSearchSentence</summary>
public class NucliadbModelsSearchSentence
{
    /// <summary>Score</summary>
    public float Score { get; set; }

    /// <summary>Rid</summary>
    public string Rid { get; set; }

    /// <summary>Text</summary>
    public string Text { get; set; }

    /// <summary>FieldType</summary>
    public string FieldType { get; set; }

    /// <summary>Field</summary>
    public string Field { get; set; }

    /// <summary>Index</summary>
    public object Index { get; set; }

    /// <summary>Position</summary>
    public object Position { get; set; }
}

/// <summary>AITables</summary>
public class AITables
{
    /// <summary>Llm</summary>
    public object Llm { get; set; }
}

/// <summary>AnthropicKey</summary>
public class AnthropicKey
{
    /// <summary>Key</summary>
    public string Key { get; set; }
}

/// <summary>AskConfig</summary>
public class AskConfig
{
    /// <summary>A dictionary containing optional audit-specific metadata, such as user_id, environment, or other contextual information. This metadata can be leveraged for filtering and analyzing activity logs in future operations. Each key-value pair represents a piece of metadata relevant to the user's request.</summary>
    public object AuditMetadata { get; set; }

    /// <summary>The top most relevant results to fetch at the retrieval step. The maximum number of results allowed is 200.</summary>
    public int TopK { get; set; }

    /// <summary>Returns only documents that match this filter expression.Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters This allows building complex filtering expressions and replaces the following parameters:`fields`, `filters`, `range_*`, `resource_filters`, `keyword_filters`.</summary>
    public object FilterExpression { get; set; }

    /// <summary>The list of fields to search in. For instance: `a/title` to search only on title field. For more details on filtering by field, see: https://docs.nuclia.dev/docs/rag/advanced/search/#search-in-a-specific-field.</summary>
    public List<string> Fields { get; set; }

    /// <summary>The list of filters to apply. Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters</summary>
    public object Filters { get; set; }

    /// <summary>List of keyword filter expressions to apply to the retrieval step. The text block search will only be performed on the documents that contain the specified keywords. The filters are case-insensitive, and only alphanumeric characters and spaces are allowed. Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters</summary>
    public object KeywordFilters { get; set; }

    /// <summary>Vectors index to perform the search in. If not provided, NucliaDB will use the default one</summary>
    public object Vectorset { get; set; }

    /// <summary>Minimum score to filter search results. Results with a lower score will be ignored. Accepts either a float or a dictionary with the minimum scores for the bm25 and vector indexes. If a float is provided, it is interpreted as the minimum score for vector index search.</summary>
    public object MinScore { get; set; }

    /// <summary>Features enabled for the chat endpoint. Semantic search is done if `semantic` is included. If `keyword` is included, the results will include matching paragraphs from the bm25 index. If `relations` is included, a graph of entities related to the answer is returned. `paragraphs` and `vectors` are deprecated, please use `keyword` and `semantic` instead</summary>
    public List<ChatOptions> Features { get; set; }

    /// <summary>Resources created before this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</summary>
    public object RangeCreationStart { get; set; }

    /// <summary>Resources created after this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</summary>
    public object RangeCreationEnd { get; set; }

    /// <summary>Resources modified before this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</summary>
    public object RangeModificationStart { get; set; }

    /// <summary>Resources modified after this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</summary>
    public object RangeModificationEnd { get; set; }

    /// <summary>Controls which types of metadata are serialized on resources of search results</summary>
    public List<ResourceProperties> Show { get; set; }

    /// <summary>Define which field types are serialized on resources of search results</summary>
    public List<FieldTypeName> FieldTypeFilter { get; set; }

    /// <summary>[Deprecated] Please use GET resource endpoint instead to get extracted metadata</summary>
    public List<ExtractedDataTypeName> Extracted { get; set; }

    /// <summary>DEPRECATED! Please, use `chat_history` instead.</summary>
    public object Context { get; set; }

    /// <summary>Use to rephrase the new LLM query by taking into account the chat conversation history. This will be passed to the LLM so that it is aware of the previous conversation.</summary>
    public object ChatHistory { get; set; }

    /// <summary>Additional context that is added to the retrieval context sent to the LLM.         It allows extending the chat feature with content that may not be in the Knowledge Box.</summary>
    public object ExtraContext { get; set; }

    /// <summary>Additional images added to the retrieval context sent to the LLM."         It allows extending the chat feature with content that may not be in the Knowledge Box.</summary>
    public object ExtraContextImages { get; set; }

    /// <summary>Image that will be used together with the query text for retrieval and then sent to the LLM as part of the context. If a query image is provided, the `extra_context_images` and `rag_images_strategies` will be disabled.</summary>
    public object QueryImage { get; set; }

    /// <summary>If set to true, the search will automatically add filters to the query. For example, it will filter results containing the entities detected in the query</summary>
    public bool Autofilter { get; set; }

    /// <summary>If set to true, the query terms will be highlighted in the results between <mark>...</mark> tags</summary>
    public bool Highlight { get; set; }

    /// <summary>List of resource ids to filter search results for. Only paragraphs from the specified resources will be returned.</summary>
    public List<string> ResourceFilters { get; set; }

    /// <summary>Use to customize the prompts given to the generative model. Both system and user prompts can be customized. If a string is provided, it is interpreted as the user prompt.</summary>
    public object Prompt { get; set; }

    /// <summary>Rank fusion algorithm to use to merge results from multiple retrievers (keyword, semantic)</summary>
    public object RankFusion { get; set; }

    /// <summary>Reranker let you specify which method you want to use to rerank your results at the end of retrieval</summary>
    public object Reranker { get; set; }

    /// <summary>Whether to include the citations for the answer in the response</summary>
    public bool Citations { get; set; }

    /// <summary>If citations is True, this sets the similarity threshold (0 to 1) for paragraphs to be included as citations. Lower values result in more citations. If not provided, Nuclia's default threshold is used.</summary>
    public object CitationThreshold { get; set; }

    /// <summary>Security metadata for the request. If not provided, the search request is done without the security lookup phase.</summary>
    public object Security { get; set; }

    /// <summary>If set to false (default), excludes hidden resources from search</summary>
    public bool ShowHidden { get; set; }

    /// <summary>Options for tweaking how the context for the LLM model is crafted: - `full_resource` will add the full text of the matching resources to the context. This strategy cannot be combined with `hierarchy`, `neighbouring_paragraphs`, or `field_extension`. - `field_extension` will add the text of the matching resource's specified fields to the context. - `hierarchy` will add the title and summary text of the parent resource to the context for each matching paragraph. - `neighbouring_paragraphs` will add the sorrounding paragraphs to the context for each matching paragraph. - `metadata_extension` will add the metadata of the matching paragraphs or its resources to the context. - `prequeries` allows to run multiple retrieval queries before the main query and add the results to the context. The results of specific queries can be boosted by the specifying weights.  If empty, the default strategy is used, which simply adds the text of the matching paragraphs to the context.</summary>
    public List<object> RagStrategies { get; set; }

    /// <summary>Options for tweaking how the image based context for the LLM model is crafted: - `page_image` will add the full page image of the matching resources to the context. - `tables` will send the table images for the paragraphs that contain tables and matched the retrieval query. - `paragraph_image` will add the images of the paragraphs that contain images (images for tables are not included). No image strategy is used by default. Note that this is only available for LLM models that support visual inputs. If the model does not support visual inputs, the image strategies will be ignored.</summary>
    public List<object> RagImagesStrategies { get; set; }

    /// <summary>If set, the response will include some extra metadata for debugging purposes, like the list of queried nodes.</summary>
    public bool Debug { get; set; }

    /// <summary>The generative model to use for the chat endpoint. If not provided, the model configured for the Knowledge Box is used.</summary>
    public object GenerativeModel { get; set; }

    /// <summary>The seed to use for the generative model for deterministic generation. Only supported by some models.</summary>
    public object GenerativeModelSeed { get; set; }

    /// <summary>Use to limit the amount of tokens used in the LLM context and/or for generating the answer. If not provided, the default maximum tokens of the generative model will be used. If an integer is provided, it is interpreted as the maximum tokens for the answer.</summary>
    public object MaxTokens { get; set; }

    /// <summary>Rephrase the query for a more efficient retrieval. This will consume LLM tokens and make the request slower.</summary>
    public bool Rephrase { get; set; }

    /// <summary>Threshold to determine if the past chat history is relevant to rephrase the user's question. 0 - Always treat previous messages as relevant (always rephrase).1 - Always treat previous messages as irrelevant (never rephrase).Values in between adjust the sensitivity.</summary>
    public object ChatHistoryRelevanceThreshold { get; set; }

    /// <summary>If set to true, the response will be in markdown format</summary>
    public bool PreferMarkdown { get; set; }

    /// <summary>Desired JSON schema for the LLM answer. This schema is passed to the LLM so that it answers in a scructured format following the schema. If not provided, textual response is returned. Note that when using this parameter, the answer in the generative response will not be returned in chunks, the whole response text will be returned instead. Using this feature also disables the `citations` parameter. For maximal accuracy, please include a `description` for each field of the schema.</summary>
    public object AnswerJsonSchema { get; set; }

    /// <summary>Whether to generate an answer using the generative model. If set to false, the response will only contain the retrieval results.</summary>
    public bool GenerateAnswer { get; set; }

    /// <summary>Reasoning options for the generative model. Set to True to enable default reasoning, False to disable, or provide a Reasoning object for custom options.</summary>
    public object Reasoning { get; set; }

    /// <summary>Query</summary>
    public object Query { get; set; }
}

/// <summary>AskSearchConfiguration</summary>
public class AskSearchConfiguration
{
    /// <summary>Kind</summary>
    public string Kind { get; set; }

    /// <summary>Config</summary>
    public AskConfig Config { get; set; }
}

/// <summary>AzureMistralKey</summary>
public class AzureMistralKey
{
    /// <summary>Key</summary>
    public string Key { get; set; }

    /// <summary>Url</summary>
    public string Url { get; set; }
}

/// <summary>AzureOpenAIKey</summary>
public class AzureOpenAIKey
{
    /// <summary>Key</summary>
    public string Key { get; set; }

    /// <summary>Url</summary>
    public string Url { get; set; }

    /// <summary>Deployment</summary>
    public string Deployment { get; set; }

    /// <summary>Model</summary>
    public string Model { get; set; }
}

/// <summary>CreateEntitiesGroupPayload</summary>
public class CreateEntitiesGroupPayload
{
    /// <summary>Group</summary>
    public string Group { get; set; }

    /// <summary>Entities</summary>
    public object Entities { get; set; }

    /// <summary>Title</summary>
    public object Title { get; set; }

    /// <summary>Color</summary>
    public object Color { get; set; }
}

/// <summary>CreateExportResponse</summary>
public class CreateExportResponse
{
    /// <summary>ExportId</summary>
    public string ExportId { get; set; }
}

/// <summary>CreateImportResponse</summary>
public class CreateImportResponse
{
    /// <summary>ImportId</summary>
    public string ImportId { get; set; }
}

/// <summary>CreateResourcePayload</summary>
public class CreateResourcePayload
{
    /// <summary>Title</summary>
    public object Title { get; set; }

    /// <summary>Summary</summary>
    public object Summary { get; set; }

    /// <summary>The slug is the user-defined id for the resource</summary>
    public object Slug { get; set; }

    /// <summary>The icon should be a media type string: https://www.iana.org/assignments/media-types/media-types.xhtml</summary>
    public object Icon { get; set; }

    /// <summary>Thumbnail</summary>
    public object Thumbnail { get; set; }

    /// <summary>Generic metadata for the resource. It can be used to store structured information about the resource that later is serialized on retrieval results, however this metadata can not be used for searching or filtering.</summary>
    public object Metadata { get; set; }

    /// <summary>Usermetadata</summary>
    public object Usermetadata { get; set; }

    /// <summary>Fieldmetadata</summary>
    public object Fieldmetadata { get; set; }

    /// <summary>Origin metadata for the resource. Used to store information about the resource on the origin system. Most of its fields can later be used to filter at search time.</summary>
    public object Origin { get; set; }

    /// <summary>Extra metadata for the resource. It can be used to store structured information about the resource that can't be used to query at retrieval time.</summary>
    public object Extra { get; set; }

    /// <summary>Set the hidden status of the resource. If not set, the default value for new resources in the KnowledgeBox will be used.</summary>
    public object Hidden { get; set; }

    /// <summary>Dictionary of file fields to be added to the resource. The keys correspond to the field id, and must comply with the regex: ^[a-zA-Z0-9:_-]+$</summary>
    public object Files { get; set; }

    /// <summary>Dictionary of link fields to be added to the resource. The keys correspond to the field id, and must comply with the regex: ^[a-zA-Z0-9:_-]+$</summary>
    public object Links { get; set; }

    /// <summary>Dictionary of text fields to be added to the resource. The keys correspond to the field id, and must comply with the regex: ^[a-zA-Z0-9:_-]+$</summary>
    public object Texts { get; set; }

    /// <summary>Dictionary of conversation fields to be added to the resource. The keys correspond to the field id, and must comply with the regex: ^[a-zA-Z0-9:_-]+$</summary>
    public object Conversations { get; set; }

    /// <summary>Options for processing the resource. If not set, the default options will be used.</summary>
    public object ProcessingOptions { get; set; }

    /// <summary>Security metadata for the resource. It can be used to have fine-grained control over who can access the resource.</summary>
    public object Security { get; set; }
}

/// <summary>CustomSplitStrategy</summary>
public class CustomSplitStrategy
{

}

/// <summary>Enum for the different external index providers. For now only Pinecone is supported, but we may add more in the future.</summary>
public class ExternalIndexProviderType
{

}

/// <summary>ExtractConfig</summary>
public class ExtractConfig
{
    /// <summary>Name</summary>
    public string Name { get; set; }

    /// <summary>VllmConfig</summary>
    public object VllmConfig { get; set; }

    /// <summary>AiTables</summary>
    public object AiTables { get; set; }

    /// <summary>Split</summary>
    public object Split { get; set; }
}

/// <summary>FieldRef</summary>
public class FieldRef
{
    /// <summary>FieldType</summary>
    public FieldTypeName FieldType { get; set; }

    /// <summary>FieldId</summary>
    public string FieldId { get; set; }

    /// <summary>Split</summary>
    public object Split { get; set; }
}

/// <summary>File</summary>
public class File
{
    /// <summary>Filename</summary>
    public object Filename { get; set; }

    /// <summary>ContentType</summary>
    public string ContentType { get; set; }

    /// <summary>Base64 encoded file content</summary>
    public object Payload { get; set; }

    /// <summary>Md5</summary>
    public object Md5 { get; set; }

    /// <summary>Uri</summary>
    public object Uri { get; set; }

    /// <summary>ExtraHeaders</summary>
    public object ExtraHeaders { get; set; }
}

/// <summary>FileB64</summary>
public class FileB64
{
    /// <summary>Filename</summary>
    public string Filename { get; set; }

    /// <summary>ContentType</summary>
    public string ContentType { get; set; }

    /// <summary>Payload</summary>
    public string Payload { get; set; }

    /// <summary>Md5</summary>
    public string Md5 { get; set; }
}

/// <summary>FileField</summary>
public class FileField
{
    /// <summary>Language</summary>
    public object Language { get; set; }

    /// <summary>Password</summary>
    public object Password { get; set; }

    /// <summary>File</summary>
    public File File { get; set; }

    /// <summary>Id of the Nuclia extract strategy to use at processing time. If not set, the default strategy will be used. Extract strategies are defined at the learning configuration api.</summary>
    public object ExtractStrategy { get; set; }

    /// <summary>Id of the Nuclia split strategy used at processing time. If not set, the default strategy was used. Split strategies are defined at the learning configuration api.</summary>
    public object SplitStrategy { get; set; }
}

/// <summary>FindConfig</summary>
public class FindConfig
{
    /// <summary>A dictionary containing optional audit-specific metadata, such as user_id, environment, or other contextual information. This metadata can be leveraged for filtering and analyzing activity logs in future operations. Each key-value pair represents a piece of metadata relevant to the user's request.</summary>
    public object AuditMetadata { get; set; }

    /// <summary>The query to search for</summary>
    public string Query { get; set; }

    /// <summary>Returns only documents that match this filter expression.Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters This allows building complex filtering expressions and replaces the following parameters:`fields`, `filters`, `range_*`, `resource_filters`, `keyword_filters`.</summary>
    public object FilterExpression { get; set; }

    /// <summary>The list of fields to search in. For instance: `a/title` to search only on title field. For more details on filtering by field, see: https://docs.nuclia.dev/docs/rag/advanced/search/#search-in-a-specific-field.</summary>
    public List<string> Fields { get; set; }

    /// <summary>The list of filters to apply. Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters</summary>
    public object Filters { get; set; }

    /// <summary>The number of results search should return. The maximum number of results allowed is 200.</summary>
    public int TopK { get; set; }

    /// <summary>Minimum score to filter search results. Results with a lower score will be ignored. Accepts either a float or a dictionary with the minimum scores for the bm25 and vector indexes. If a float is provided, it is interpreted as the minimum score for vector index search.</summary>
    public object MinScore { get; set; }

    /// <summary>Resources created before this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</summary>
    public object RangeCreationStart { get; set; }

    /// <summary>Resources created after this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</summary>
    public object RangeCreationEnd { get; set; }

    /// <summary>Resources modified before this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</summary>
    public object RangeModificationStart { get; set; }

    /// <summary>Resources modified after this date will be filtered out of search results. Datetime are represented as a str in ISO 8601 format, like: 2008-09-15T15:53:00+05:00.</summary>
    public object RangeModificationEnd { get; set; }

    /// <summary>If set, the response will include some extra metadata for debugging purposes, like the list of queried nodes.</summary>
    public bool Debug { get; set; }

    /// <summary>If set to true, the query terms will be highlighted in the results between <mark>...</mark> tags</summary>
    public bool Highlight { get; set; }

    /// <summary>Controls which types of metadata are serialized on resources of search results</summary>
    public List<ResourceProperties> Show { get; set; }

    /// <summary>Define which field types are serialized on resources of search results</summary>
    public List<FieldTypeName> FieldTypeFilter { get; set; }

    /// <summary>[Deprecated] Please use GET resource endpoint instead to get extracted metadata</summary>
    public List<ExtractedDataTypeName> Extracted { get; set; }

    /// <summary>The vector to perform the search with. If not provided, NucliaDB will use Nuclia Predict API to create the vector off from the query.</summary>
    public object Vector { get; set; }

    /// <summary>Vectors index to perform the search in. If not provided, NucliaDB will use the default one</summary>
    public object Vectorset { get; set; }

    /// <summary>Whether to return duplicate paragraphs on the same document</summary>
    public bool WithDuplicates { get; set; }

    /// <summary>Whether to return matches for custom knowledge box synonyms of the query terms. Note: only supported for `keyword` and `fulltext` search options.</summary>
    public bool WithSynonyms { get; set; }

    /// <summary>If set to true, the search will automatically add filters to the query. For example, it will filter results containing the entities detected in the query</summary>
    public bool Autofilter { get; set; }

    /// <summary>List of resource ids to filter search results for. Only paragraphs from the specified resources will be returned.</summary>
    public List<string> ResourceFilters { get; set; }

    /// <summary>Security metadata for the request. If not provided, the search request is done without the security lookup phase.</summary>
    public object Security { get; set; }

    /// <summary>If set to false (default), excludes hidden resources from search</summary>
    public bool ShowHidden { get; set; }

    /// <summary>Rephrase the query for a more efficient retrieval. This will consume LLM tokens and make the request slower.</summary>
    public bool Rephrase { get; set; }

    /// <summary>Rephrase prompt given to the generative model responsible for rephrasing the query for a more effective retrieval step. This is only used if the `rephrase` flag is set to true in the request. If not specified, Nuclia's default prompt is used. It must include the {question} placeholder. The placeholder will be replaced with the original question</summary>
    public object RephrasePrompt { get; set; }

    /// <summary>Image that will be used together with the query text for retrieval.</summary>
    public object QueryImage { get; set; }

    /// <summary>Query for the knowledge graph. Paths (node-relation-node) extracted from a paragraph_id will be used to extend the results</summary>
    public object GraphQuery { get; set; }

    /// <summary>List of search features to use. Each value corresponds to a lookup into on of the different indexes</summary>
    public List<FindOptions> Features { get; set; }

    /// <summary>Rank fusion algorithm to use to merge results from multiple retrievers (keyword, semantic)</summary>
    public object RankFusion { get; set; }

    /// <summary>Reranker let you specify which method you want to use to rerank your results at the end of retrieval</summary>
    public object Reranker { get; set; }

    /// <summary>List of keyword filter expressions to apply to the retrieval step. The text block search will only be performed on the documents that contain the specified keywords. The filters are case-insensitive, and only alphanumeric characters and spaces are allowed. Filtering examples can be found here: https://docs.nuclia.dev/docs/rag/advanced/search-filters</summary>
    public object KeywordFilters { get; set; }

    /// <summary>The generative model used to rephrase the query. If not provided, the model configured for the Knowledge Box is used.</summary>
    public object GenerativeModel { get; set; }
}

/// <summary>FindSearchConfiguration</summary>
public class FindSearchConfiguration
{
    /// <summary>Kind</summary>
    public string Kind { get; set; }

    /// <summary>Config</summary>
    public FindConfig Config { get; set; }
}

/// <summary>GraphNode</summary>
public class GraphNode
{
    /// <summary>Value</summary>
    public object Value { get; set; }

    /// <summary>Match</summary>
    public NodeMatchKindName Match { get; set; }

    /// <summary>Type</summary>
    public object Type { get; set; }

    /// <summary>Group</summary>
    public object Group { get; set; }
}

/// <summary>GraphPath</summary>
public class GraphPath
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>Source</summary>
    public object Source { get; set; }

    /// <summary>Relation</summary>
    public object Relation { get; set; }

    /// <summary>Destination</summary>
    public object Destination { get; set; }

    /// <summary>Undirected</summary>
    public bool Undirected { get; set; }
}

/// <summary>GraphRelation</summary>
public class GraphRelation
{
    /// <summary>Label</summary>
    public object Label { get; set; }

    /// <summary>Type</summary>
    public object Type { get; set; }
}

/// <summary>Some models require a specific template (including prefix) to work correctly in each task For example Snowflake's Arctic-embed requires a specific prefix to work correctly. In that case, the query prompt will be ``` passage_prompt: "" query_prompt: "Represent this sentence for searching relevant passages: {}" ```` where {} will be replaced by the actual sentence. `passage_prompt` is empty because the model does not require alterations to the sentence to embed is as a passage.</summary>
public class HFEmbeddingKey
{
    /// <summary>Url</summary>
    public string Url { get; set; }

    /// <summary>Key</summary>
    public string Key { get; set; }

    /// <summary>Matryoshka</summary>
    public List<int> Matryoshka { get; set; }

    /// <summary>Similarity</summary>
    public string Similarity { get; set; }

    /// <summary>Size</summary>
    public int Size { get; set; }

    /// <summary>Threshold</summary>
    public float Threshold { get; set; }

    /// <summary>PassagePrompt</summary>
    public string PassagePrompt { get; set; }

    /// <summary>QueryPrompt</summary>
    public string QueryPrompt { get; set; }
}

/// <summary>HFLLMKey</summary>
public class HFLLMKey
{
    /// <summary>Key</summary>
    public string Key { get; set; }

    /// <summary>Url</summary>
    public string Url { get; set; }

    /// <summary>Model</summary>
    public ModelType Model { get; set; }
}

/// <summary>InputConversationField</summary>
public class InputConversationField
{
    /// <summary>List of messages in the conversation field. Each message must have a unique ident.</summary>
    public List<InputMessage> Messages { get; set; }

    /// <summary>Id of the Nuclia extract strategy used at processing time. If not set, the default strategy was used. Extract strategies are defined at the learning configuration api.</summary>
    public object ExtractStrategy { get; set; }

    /// <summary>Id of the Nuclia split strategy used at processing time. If not set, the default strategy was used. Split strategies are defined at the learning configuration api.</summary>
    public object SplitStrategy { get; set; }
}

/// <summary>InputMessage</summary>
public class InputMessage
{
    /// <summary>Time at which the message was sent, in ISO 8601 format.</summary>
    public object Timestamp { get; set; }

    /// <summary>Sender of the message, e.g. 'user' or 'assistant'</summary>
    public object Who { get; set; }

    /// <summary>List of recipients of the message, e.g. ['assistant'] or ['user']</summary>
    public List<string> To { get; set; }

    /// <summary>Content</summary>
    public InputMessageContent Content { get; set; }

    /// <summary>Unique identifier for the message. Must be unique within the conversation.</summary>
    public string Ident { get; set; }

    /// <summary>Type</summary>
    public object Type { get; set; }
}

/// <summary>InputMessageContent</summary>
public class InputMessageContent
{
    /// <summary>Text</summary>
    public string Text { get; set; }

    /// <summary>Format</summary>
    public MessageFormat Format { get; set; }

    /// <summary>Attachments</summary>
    public List<FileB64> Attachments { get; set; }

    /// <summary>AttachmentsFields</summary>
    public List<FieldRef> AttachmentsFields { get; set; }
}

/// <summary>InputMetadata</summary>
public class InputMetadata
{
    /// <summary>Metadata</summary>
    public object Metadata { get; set; }

    /// <summary>Language</summary>
    public object Language { get; set; }

    /// <summary>Languages</summary>
    public object Languages { get; set; }
}

/// <summary>InputOrigin</summary>
public class InputOrigin
{
    /// <summary>SourceId</summary>
    public object SourceId { get; set; }

    /// <summary>Url</summary>
    public object Url { get; set; }

    /// <summary>Creation date of the resource at the origin system. This can be later used for date range filtering on search endpoints. Have a look at the advanced search documentation page: https://docs.nuclia.dev/docs/rag/advanced/search/#date-filtering</summary>
    public object Created { get; set; }

    /// <summary>Modification date of the resource at the origin system. This can be later used for date range filtering on search endpoints.  Have a look at the advanced search documentation page: https://docs.nuclia.dev/docs/rag/advanced/search/#date-filtering</summary>
    public object Modified { get; set; }

    /// <summary>Generic metadata from the resource at the origin system. It can later be used for filtering on search endpoints with '/origin.metadata/{key}/{value}'</summary>
    public object Metadata { get; set; }

    /// <summary>Resource tags about the origin system. It can later be used for filtering on search endpoints with '/origin.tags/{tag}'</summary>
    public List<string> Tags { get; set; }

    /// <summary>Collaborators</summary>
    public List<string> Collaborators { get; set; }

    /// <summary>Filename</summary>
    public object Filename { get; set; }

    /// <summary>Related</summary>
    public List<string> Related { get; set; }

    /// <summary>Path of the original resource. Typically used to store folder structure information of the resource at the origin system. It can be later used for filtering on search endpoints with '/origin.path/{path}'</summary>
    public object Path { get; set; }
}

/// <summary>KnowledgeBoxConfigInput</summary>
public class KnowledgeBoxConfigInput
{
    /// <summary>Slug for the Knowledge Box.</summary>
    public object Slug { get; set; }

    /// <summary>Title for the Knowledge Box.</summary>
    public object Title { get; set; }

    /// <summary>Description for the Knowledge Box.</summary>
    public object Description { get; set; }

    /// <summary>Learning configuration for the Knowledge Box. If provided, NucliaDB will set the learning configuration for the Knowledge Box.</summary>
    public object LearningConfiguration { get; set; }

    /// <summary>External index provider for the Knowledge Box.</summary>
    public object ExternalIndexProvider { get; set; }

    /// <summary>Metadata for the configured external index provider (if any)</summary>
    public object ConfiguredExternalIndexProvider { get; set; }

    /// <summary>This field is deprecated. Use 'learning_configuration' instead.</summary>
    public object Similarity { get; set; }

    /// <summary>Allow hiding resources</summary>
    public bool HiddenResourcesEnabled { get; set; }

    /// <summary>Hide newly created resources</summary>
    public bool HiddenResourcesHideOnCreation { get; set; }
}

/// <summary>KnowledgeBoxConfigOutput</summary>
public class KnowledgeBoxConfigOutput
{
    /// <summary>Slug for the Knowledge Box.</summary>
    public object Slug { get; set; }

    /// <summary>Title for the Knowledge Box.</summary>
    public object Title { get; set; }

    /// <summary>Description for the Knowledge Box.</summary>
    public object Description { get; set; }

    /// <summary>Learning configuration for the Knowledge Box. If provided, NucliaDB will set the learning configuration for the Knowledge Box.</summary>
    public object LearningConfiguration { get; set; }

    /// <summary>External index provider for the Knowledge Box.</summary>
    public object ExternalIndexProvider { get; set; }

    /// <summary>Metadata for the configured external index provider (if any)</summary>
    public object ConfiguredExternalIndexProvider { get; set; }

    /// <summary>This field is deprecated. Use 'learning_configuration' instead.</summary>
    public object Similarity { get; set; }

    /// <summary>Allow hiding resources</summary>
    public bool HiddenResourcesEnabled { get; set; }

    /// <summary>Hide newly created resources</summary>
    public bool HiddenResourcesHideOnCreation { get; set; }
}

/// <summary>The API representation of a Knowledge Box object.</summary>
public class KnowledgeBoxObj
{
    /// <summary>Slug</summary>
    public object Slug { get; set; }

    /// <summary>Uuid</summary>
    public string Uuid { get; set; }

    /// <summary>Config</summary>
    public object Config { get; set; }

    /// <summary>Model</summary>
    public object Model { get; set; }
}

/// <summary>KnowledgeBoxObjID</summary>
public class KnowledgeBoxObjID
{
    /// <summary>Uuid</summary>
    public string Uuid { get; set; }
}

/// <summary>KnowledgeBoxSynonyms</summary>
public class KnowledgeBoxSynonyms
{
    /// <summary>Synonyms</summary>
    public object Synonyms { get; set; }
}

/// <summary>LLMConfig</summary>
public class LLMConfig
{
    /// <summary>UserKeys</summary>
    public object UserKeys { get; set; }

    /// <summary>GenerativeModel</summary>
    public string GenerativeModel { get; set; }

    /// <summary>GenerativeProvider</summary>
    public string GenerativeProvider { get; set; }

    /// <summary>GenerativePromptId</summary>
    public string GenerativePromptId { get; set; }
}

/// <summary>LLMSplitConfig</summary>
public class LLMSplitConfig
{
    /// <summary>Rules</summary>
    public List<string> Rules { get; set; }

    /// <summary>Llm</summary>
    public object Llm { get; set; }
}

/// <summary>LabelSet</summary>
public class LabelSet
{
    /// <summary>Title</summary>
    public object Title { get; set; }

    /// <summary>Color</summary>
    public object Color { get; set; }

    /// <summary>Multiple</summary>
    public bool Multiple { get; set; }

    /// <summary>Kind</summary>
    public List<LabelSetKind> Kind { get; set; }

    /// <summary>Labels</summary>
    public List<NucliadbModelsLabelsLabel> Labels { get; set; }
}

/// <summary>LabelSetKind</summary>
public class LabelSetKind
{

}

/// <summary>LinkField</summary>
public class LinkField
{
    /// <summary>Headers</summary>
    public object Headers { get; set; }

    /// <summary>Cookies</summary>
    public object Cookies { get; set; }

    /// <summary>Uri</summary>
    public string Uri { get; set; }

    /// <summary>Language</summary>
    public object Language { get; set; }

    /// <summary>Localstorage</summary>
    public object Localstorage { get; set; }

    /// <summary>CssSelector</summary>
    public object CssSelector { get; set; }

    /// <summary>Xpath</summary>
    public object Xpath { get; set; }

    /// <summary>Id of the Nuclia extract strategy to use at processing time. If not set, the default strategy will be used. Extract strategies are defined at the learning configuration api.</summary>
    public object ExtractStrategy { get; set; }

    /// <summary>Id of the Nuclia split strategy used at processing time. If not set, the default strategy was used. Split strategies are defined at the learning configuration api.</summary>
    public object SplitStrategy { get; set; }
}

/// <summary>ManualSplitConfig</summary>
public class ManualSplitConfig
{
    /// <summary>Splitter</summary>
    public string Splitter { get; set; }
}

/// <summary>MessageFormat</summary>
public class MessageFormat
{

}

/// <summary>MessageType</summary>
public class MessageType
{

}

/// <summary>MistralKey</summary>
public class MistralKey
{
    /// <summary>Key</summary>
    public string Key { get; set; }
}

/// <summary>ModelType</summary>
public class ModelType
{

}

/// <summary>NewImportedKbResponse</summary>
public class NewImportedKbResponse
{
    /// <summary>Kbid</summary>
    public string Kbid { get; set; }

    /// <summary>Slug</summary>
    public string Slug { get; set; }
}

/// <summary>OpenAIKey</summary>
public class OpenAIKey
{
    /// <summary>Key</summary>
    public string Key { get; set; }

    /// <summary>Org</summary>
    public string Org { get; set; }
}

/// <summary>PalmKey</summary>
public class PalmKey
{
    /// <summary>Credentials</summary>
    public string Credentials { get; set; }

    /// <summary>Location</summary>
    public string Location { get; set; }
}

/// <summary>PineconeIndexProvider</summary>
public class PineconeIndexProvider
{
    /// <summary>Type</summary>
    public ExternalIndexProviderType Type { get; set; }

    /// <summary>ApiKey</summary>
    public string ApiKey { get; set; }

    /// <summary>ServerlessCloud</summary>
    public PineconeServerlessCloud ServerlessCloud { get; set; }
}

/// <summary>List of cloud providers supported by Pinecone serverless vector database.</summary>
public class PineconeServerlessCloud
{

}

/// <summary>PushProcessingOptions</summary>
public class PushProcessingOptions
{
    /// <summary>MlText</summary>
    public object MlText { get; set; }
}

/// <summary>Matches all fields of a resource given its id or slug</summary>
public class Resource
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>UUID of the resource to match</summary>
    public object Id { get; set; }

    /// <summary>Slug of the resource to match</summary>
    public object Slug { get; set; }
}

/// <summary>ResourceCreated</summary>
public class ResourceCreated
{
    /// <summary>Uuid</summary>
    public string Uuid { get; set; }

    /// <summary>Elapsed</summary>
    public object Elapsed { get; set; }

    /// <summary>Seqid</summary>
    public object Seqid { get; set; }
}

/// <summary>ResourceFieldAdded</summary>
public class ResourceFieldAdded
{
    /// <summary>Seqid</summary>
    public object Seqid { get; set; }
}

/// <summary>ResourceFileUploaded</summary>
public class ResourceFileUploaded
{
    /// <summary>Seqid</summary>
    public object Seqid { get; set; }

    /// <summary>Uuid</summary>
    public object Uuid { get; set; }

    /// <summary>FieldId</summary>
    public object FieldId { get; set; }
}

/// <summary>ResourceUpdated</summary>
public class ResourceUpdated
{
    /// <summary>Seqid</summary>
    public object Seqid { get; set; }
}

/// <summary>Metadata of the semantic model associated to the KB</summary>
public class SemanticModelMetadata
{
    /// <summary>SimilarityFunction</summary>
    public VectorSimilarity SimilarityFunction { get; set; }

    /// <summary>Dimension of the indexed vectors/embeddings</summary>
    public object VectorDimension { get; set; }

    /// <summary>Deprecated</summary>
    public object DefaultMinScore { get; set; }
}

/// <summary>SplitConfig</summary>
public class SplitConfig
{
    /// <summary>MaxParagraph</summary>
    public int MaxParagraph { get; set; }
}

/// <summary>Hey, developer! Keep this in sync with corresponding pydantic model in learning_config.models</summary>
public class SplitConfiguration
{
    /// <summary>Name</summary>
    public string Name { get; set; }

    /// <summary>MaxParagraph</summary>
    public int MaxParagraph { get; set; }

    /// <summary>CustomSplit</summary>
    public object CustomSplit { get; set; }

    /// <summary>LlmSplit</summary>
    public object LlmSplit { get; set; }

    /// <summary>ManualSplit</summary>
    public object ManualSplit { get; set; }
}

/// <summary>TextField</summary>
public class TextField
{
    /// <summary>The text body. The format of the text should be specified in the format field. The sum of all text fields in the request may not exceed 2MB. If you need to store more text, consider using a file field instead or splitting into multiple requests for each text field.</summary>
    public string Body { get; set; }

    /// <summary>Format</summary>
    public TextFormat Format { get; set; }

    /// <summary>Id of the Nuclia extract strategy to use at processing time. If not set, the default strategy will be used. Extract strategies are defined at the learning configuration api.</summary>
    public object ExtractStrategy { get; set; }

    /// <summary>Id of the Nuclia split strategy used at processing time. If not set, the default strategy was used. Split strategies are defined at the learning configuration api.</summary>
    public object SplitStrategy { get; set; }
}

/// <summary>TextGenerationKey</summary>
public class TextGenerationKey
{
    /// <summary>Model</summary>
    public string Model { get; set; }
}

/// <summary>UpdateEntitiesGroupPayload</summary>
public class UpdateEntitiesGroupPayload
{
    /// <summary>Title</summary>
    public object Title { get; set; }

    /// <summary>Color</summary>
    public object Color { get; set; }

    /// <summary>Add</summary>
    public object Add { get; set; }

    /// <summary>Update</summary>
    public object Update { get; set; }

    /// <summary>Delete</summary>
    public List<string> Delete { get; set; }
}

/// <summary>UpdateResourcePayload</summary>
public class UpdateResourcePayload
{
    /// <summary>Title</summary>
    public object Title { get; set; }

    /// <summary>Summary</summary>
    public object Summary { get; set; }

    /// <summary>The slug is the user-defined id for the resource</summary>
    public object Slug { get; set; }

    /// <summary>Thumbnail</summary>
    public object Thumbnail { get; set; }

    /// <summary>Metadata</summary>
    public object Metadata { get; set; }

    /// <summary>Usermetadata</summary>
    public object Usermetadata { get; set; }

    /// <summary>Fieldmetadata</summary>
    public object Fieldmetadata { get; set; }

    /// <summary>Origin</summary>
    public object Origin { get; set; }

    /// <summary>Extra metadata for the resource. It can be used to store structured information about the resource that can't be used to query at retrieval time. If not set, the existing extra metadata will not be modified.</summary>
    public object Extra { get; set; }

    /// <summary>Dictionary of file fields to be added to the resource. The keys correspond to the field id, and must comply with the regex: ^[a-zA-Z0-9:_-]+$</summary>
    public object Files { get; set; }

    /// <summary>Dictionary of link fields to be added to the resource. The keys correspond to the field id, and must comply with the regex: ^[a-zA-Z0-9:_-]+$</summary>
    public object Links { get; set; }

    /// <summary>Dictionary of text fields to be added to the resource. The keys correspond to the field id, and must comply with the regex: ^[a-zA-Z0-9:_-]+$</summary>
    public object Texts { get; set; }

    /// <summary>Dictionary of conversation fields to be added to the resource. The keys correspond to the field id, and must comply with the regex: ^[a-zA-Z0-9:_-]+$</summary>
    public object Conversations { get; set; }

    /// <summary>Options for processing the resource. If not set, the default options will be used.</summary>
    public object ProcessingOptions { get; set; }

    /// <summary>Security metadata for the resource. It can be used to have fine-grained control over who can access the resource.</summary>
    public object Security { get; set; }

    /// <summary>Modify the hidden status of the resource. If not set, the hidden status will not be modified.</summary>
    public object Hidden { get; set; }
}

/// <summary>UserLearningKeys</summary>
public class UserLearningKeys
{
    /// <summary>Openai</summary>
    public object Openai { get; set; }

    /// <summary>AzureOpenai</summary>
    public object AzureOpenai { get; set; }

    /// <summary>Palm</summary>
    public object Palm { get; set; }

    /// <summary>Anthropic</summary>
    public object Anthropic { get; set; }

    /// <summary>Claude3</summary>
    public object Claude3 { get; set; }

    /// <summary>TextGeneration</summary>
    public object TextGeneration { get; set; }

    /// <summary>Mistral</summary>
    public object Mistral { get; set; }

    /// <summary>AzureMistral</summary>
    public object AzureMistral { get; set; }

    /// <summary>HfLlm</summary>
    public object HfLlm { get; set; }

    /// <summary>HfEmbedding</summary>
    public object HfEmbedding { get; set; }
}

/// <summary>VLLMExtractionConfig</summary>
public class VLLMExtractionConfig
{
    /// <summary>Rules</summary>
    public List<string> Rules { get; set; }

    /// <summary>Llm</summary>
    public object Llm { get; set; }
}

/// <summary>VectorSimilarity</summary>
public class VectorSimilarity
{

}

/// <summary>NucliadbModelsEntitiesEntity</summary>
public class NucliadbModelsEntitiesEntity
{
    /// <summary>Value</summary>
    public string Value { get; set; }

    /// <summary>Merged</summary>
    public bool Merged { get; set; }

    /// <summary>Represents</summary>
    public List<string> Represents { get; set; }
}

/// <summary>Matches fields that contains a detected entity</summary>
public class NucliadbModelsFiltersEntity
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>Type of the entity. e.g: PERSON</summary>
    public string Subtype { get; set; }

    /// <summary>Value of the entity. e.g: Anna. If blank, matches any entity of the given type</summary>
    public object Value { get; set; }
}

/// <summary>Matches fields/paragraphs with a label (or labelset)</summary>
public class NucliadbModelsFiltersLabel
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>The labelset to match</summary>
    public string Labelset { get; set; }

    /// <summary>The label to match. If blank, matches all labels in the given labelset</summary>
    public object Label { get; set; }
}

/// <summary>NucliadbModelsGraphRequestsRelation</summary>
public class NucliadbModelsGraphRequestsRelation
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>Label</summary>
    public object Label { get; set; }

    /// <summary>Type</summary>
    public object Type { get; set; }
}

/// <summary>NucliadbModelsLabelsLabel</summary>
public class NucliadbModelsLabelsLabel
{
    /// <summary>Title</summary>
    public string Title { get; set; }

    /// <summary>Related</summary>
    public object Related { get; set; }

    /// <summary>Text</summary>
    public object Text { get; set; }

    /// <summary>Uri</summary>
    public object Uri { get; set; }
}

/// <summary>NucliadbModelsMetadataRelation</summary>
public class NucliadbModelsMetadataRelation
{
    /// <summary>Relation</summary>
    public RelationType Relation { get; set; }

    /// <summary>Label</summary>
    public object Label { get; set; }

    /// <summary>Metadata</summary>
    public object Metadata { get; set; }

    /// <summary>From</summary>
    public object From { get; set; }

    /// <summary>To</summary>
    public RelationEntity To { get; set; }
}

/// <summary>EntitiesGroup</summary>
public class EntitiesGroup
{
    /// <summary>Title of the entities group</summary>
    public object Title { get; set; }

    /// <summary>Color of the entities group. This is for display purposes only.</summary>
    public object Color { get; set; }

    /// <summary>Denotes if it has been created by the user</summary>
    public bool Custom { get; set; }

    /// <summary>Entities</summary>
    public object Entities { get; set; }
}

/// <summary>EntitiesGroupSummary</summary>
public class EntitiesGroupSummary
{
    /// <summary>Title of the entities group</summary>
    public object Title { get; set; }

    /// <summary>Color of the entities group. This is for display purposes only.</summary>
    public object Color { get; set; }

    /// <summary>Denotes if it has been created by the user</summary>
    public bool Custom { get; set; }

    /// <summary>This field is deprecated and will be removed in future versions. It will always be empty. Use the /api/v1/kb/{kbid}/entitiesgroup/{group} endpoint to get the entities of a group.</summary>
    public object Entities { get; set; }
}

/// <summary>KnowledgeBoxConfig</summary>
public class KnowledgeBoxConfig
{
    /// <summary>Slug for the Knowledge Box.</summary>
    public object Slug { get; set; }

    /// <summary>Title for the Knowledge Box.</summary>
    public object Title { get; set; }

    /// <summary>Description for the Knowledge Box.</summary>
    public object Description { get; set; }

    /// <summary>Learning configuration for the Knowledge Box. If provided, NucliaDB will set the learning configuration for the Knowledge Box.</summary>
    public object LearningConfiguration { get; set; }

    /// <summary>External index provider for the Knowledge Box.</summary>
    public object ExternalIndexProvider { get; set; }

    /// <summary>Metadata for the configured external index provider (if any)</summary>
    public object ConfiguredExternalIndexProvider { get; set; }

    /// <summary>This field is deprecated. Use 'learning_configuration' instead.</summary>
    public object Similarity { get; set; }

    /// <summary>Allow hiding resources</summary>
    public bool HiddenResourcesEnabled { get; set; }

    /// <summary>Hide newly created resources</summary>
    public bool HiddenResourcesHideOnCreation { get; set; }
}

/// <summary>KnowledgeBoxEntities</summary>
public class KnowledgeBoxEntities
{
    /// <summary>Uuid</summary>
    public string Uuid { get; set; }

    /// <summary>Groups</summary>
    public object Groups { get; set; }
}

/// <summary>KnowledgeBoxLabels</summary>
public class KnowledgeBoxLabels
{
    /// <summary>Uuid</summary>
    public string Uuid { get; set; }

    /// <summary>Labelsets</summary>
    public object Labelsets { get; set; }
}

/// <summary>Paragraph</summary>
public class Paragraph
{
    /// <summary>Start</summary>
    public object Start { get; set; }

    /// <summary>End</summary>
    public object End { get; set; }

    /// <summary>StartSeconds</summary>
    public object StartSeconds { get; set; }

    /// <summary>EndSeconds</summary>
    public object EndSeconds { get; set; }

    /// <summary>Kind</summary>
    public object Kind { get; set; }

    /// <summary>Classifications</summary>
    public object Classifications { get; set; }

    /// <summary>Sentences</summary>
    public object Sentences { get; set; }

    /// <summary>Key</summary>
    public object Key { get; set; }

    /// <summary>Page</summary>
    public object Page { get; set; }

    /// <summary>Representation</summary>
    public object Representation { get; set; }

    /// <summary>Relations</summary>
    public object Relations { get; set; }
}

/// <summary>RequestsResult</summary>
public class RequestsResult
{
    /// <summary>Processing ID of the resource.</summary>
    public string ProcessingId { get; set; }

    /// <summary>Resource ID.</summary>
    public string ResourceId { get; set; }

    /// <summary>Kbid</summary>
    public string Kbid { get; set; }

    /// <summary>Title of the resource.</summary>
    public object Title { get; set; }

    /// <summary>Labels of the resource.</summary>
    public List<string> Labels { get; set; }

    /// <summary>Whether the resource has been completed</summary>
    public bool Completed { get; set; }

    /// <summary>Whether the resource has been scheduled</summary>
    public bool Scheduled { get; set; }

    /// <summary>Timestamp of when the resource was first scheduled.</summary>
    public string Timestamp { get; set; }

    /// <summary>Timestamp of when the resource was completed</summary>
    public object CompletedAt { get; set; }

    /// <summary>Timestamp of when the resource was first scheduled.</summary>
    public object ScheduledAt { get; set; }

    /// <summary>Whether the resource has failed to process</summary>
    public bool Failed { get; set; }

    /// <summary>Number of retries for the resource.</summary>
    public int Retries { get; set; }

    /// <summary>Estimated time until the resource is scheduled.</summary>
    public float ScheduleEta { get; set; }

    /// <summary>Order of the resource in the schedule queue.</summary>
    public int ScheduleOrder { get; set; }
}

/// <summary>RequestsResults</summary>
public class RequestsResults
{
    /// <summary>List of results.</summary>
    public List<RequestsResult> Results { get; set; }

    /// <summary>Cursor to use for the next page of results.</summary>
    public object Cursor { get; set; }
}

/// <summary>ResourceField</summary>
public class ResourceField
{
    /// <summary>FieldType</summary>
    public FieldTypeName FieldType { get; set; }

    /// <summary>FieldId</summary>
    public string FieldId { get; set; }

    /// <summary>Value</summary>
    public object Value { get; set; }

    /// <summary>Extracted</summary>
    public object Extracted { get; set; }

    /// <summary>Error</summary>
    public object Error { get; set; }

    /// <summary>Status</summary>
    public object Status { get; set; }

    /// <summary>Errors</summary>
    public object Errors { get; set; }
}

/// <summary>ResourceFieldProperties</summary>
public class ResourceFieldProperties
{

}

/// <summary>ResourceList</summary>
public class ResourceList
{
    /// <summary>Resources</summary>
    public List<NucliadbModelsResourceResource> Resources { get; set; }

    /// <summary>Pagination</summary>
    public ResourcePagination Pagination { get; set; }
}

/// <summary>ResourcePagination</summary>
public class ResourcePagination
{
    /// <summary>Page</summary>
    public int Page { get; set; }

    /// <summary>Size</summary>
    public int Size { get; set; }

    /// <summary>Last</summary>
    public bool Last { get; set; }
}

/// <summary>Sentence</summary>
public class Sentence
{
    /// <summary>Start</summary>
    public object Start { get; set; }

    /// <summary>End</summary>
    public object End { get; set; }

    /// <summary>Key</summary>
    public object Key { get; set; }
}

/// <summary>StatusResponse</summary>
public class StatusResponse
{
    /// <summary>Status</summary>
    public Status Status { get; set; }

    /// <summary>Total</summary>
    public int Total { get; set; }

    /// <summary>Processed</summary>
    public int Processed { get; set; }

    /// <summary>Retries</summary>
    public int Retries { get; set; }
}

/// <summary>NucliadbModelsExtractedEntity</summary>
public class NucliadbModelsExtractedEntity
{
    /// <summary>Token</summary>
    public object Token { get; set; }

    /// <summary>Root</summary>
    public object Root { get; set; }

    /// <summary>Type</summary>
    public object Type { get; set; }
}

/// <summary>Matches all fields of a resource given its id or slug</summary>
public class NucliadbModelsFiltersResource
{
    /// <summary>Prop</summary>
    public string Prop { get; set; }

    /// <summary>UUID of the resource to match</summary>
    public object Id { get; set; }

    /// <summary>Slug of the resource to match</summary>
    public object Slug { get; set; }
}

/// <summary>NucliadbModelsResourceResource</summary>
public class NucliadbModelsResourceResource
{
    /// <summary>Id</summary>
    public string Id { get; set; }

    /// <summary>Slug</summary>
    public object Slug { get; set; }

    /// <summary>Title</summary>
    public object Title { get; set; }

    /// <summary>Summary</summary>
    public object Summary { get; set; }

    /// <summary>Icon</summary>
    public object Icon { get; set; }

    /// <summary>Thumbnail</summary>
    public object Thumbnail { get; set; }

    /// <summary>Metadata</summary>
    public object Metadata { get; set; }

    /// <summary>Usermetadata</summary>
    public object Usermetadata { get; set; }

    /// <summary>Fieldmetadata</summary>
    public object Fieldmetadata { get; set; }

    /// <summary>Computedmetadata</summary>
    public object Computedmetadata { get; set; }

    /// <summary>Created</summary>
    public object Created { get; set; }

    /// <summary>Modified</summary>
    public object Modified { get; set; }

    /// <summary>LastSeqid</summary>
    public object LastSeqid { get; set; }

    /// <summary>LastAccountSeq</summary>
    public object LastAccountSeq { get; set; }

    /// <summary>Queue</summary>
    public object Queue { get; set; }

    /// <summary>Hidden</summary>
    public object Hidden { get; set; }

    /// <summary>Origin</summary>
    public object Origin { get; set; }

    /// <summary>Extra</summary>
    public object Extra { get; set; }

    /// <summary>Relations</summary>
    public object Relations { get; set; }

    /// <summary>Data</summary>
    public object Data { get; set; }

    /// <summary>Resource security metadata</summary>
    public object Security { get; set; }
}